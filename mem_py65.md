# Introduction

![Memorable Sunrise](images/sunrise.jpg){#figcaption:sunrise}

Welcome to Memorable Python! I'm so excited you're here. You're embarking on an awesome learning journey!‚õµÔ∏è

Not long ago I was in your shoes. I wanted to learn Python. Unfortunately, hunting through blog posts, scouring the Python docs, and  reading Stack Overflow was slow going. Many of the resources I found weren't right for my knowledge level or were outdated. Many of the books I found were dry references. They tried to cram in tons of info at the expense of making the content memorable. 

I wrote Memorable Python to fill the need for a book to help you learn Python faster. Memorable Python takes a brain-friendly approach that marries the latest in psychology and education research with the key topics you need to know to use Python effectively. 

Learning a technical topic doesn't have to be dry. In fact, material that's more engaging is easier to learn. So don't let the breezy style fool you, there's lots of good technical content ahead. 

## Is this Book For You?
This book is for you if you are early in your Python learning journey. Maybe you've done some drag and drop with Scratch or a similar program. Maybe you've dabbled in Python but want to learn it better. Maybe you've never written a piece of code. Maybe you're a manager who wants to understand Python at a high level. Maybe you're be an aspiring data engineer, data scientist, or product manager. 

If you're in any of these situations, then this book is for you. üòÄ

This book isn't for you if you've been programming in Python for the past 20 years. However, you might want to use the book to help other people learn. 

If you like reading with emojis, get the .epub version of the book from [the Memorable Python book website](https://memorablepython.com). The Kindle format doesn't support emoji. ‚òπÔ∏è

## Why Python?
Python is the ideal language to learn for several reasons.

First, Python is in demand. It's the primary language for artificial intelligence, data science, and machine learning. If you do scientific or numerical computing, big data engineering, or data science, Python is the language to know.

Second, Python is likely to continue to be in demand. It's the fastest growing major language. Stack Overflow, the most popular programming question and answer site, conducted a developer survey in [2019](https://insights.stackoverflow.com/survey/2019). They concluded:

> Python, the fastest-growing major programming language, has risen in the ranks of programming languages in our survey yet again, edging out Java this year and standing as the second most loved language.

Many [other surveys](https://spectrum.ieee.org/computing/software/the-top-programming-languages-2019) rank Python at or near the top of the most popular programming languages.

Third, you can build so much with Python. With a rich ecosystem of community-built libraries you can easily scrape data from the web, build a deep neural network, or build a website. 

Fourth, Python is easier to learn than most other programming languages. It looks more like English than many  languages you might have seen. It doesn't require loads of semicolons, question marks, or greater-than signs. Yeah! 

Fifth, although Python is nice to learn, it's syntax is relatively similar to many other languages's. If you learn Python as a first language, you're well positioned to learn other languages later.

Sixth, Python is relatively stable. The language is finally unified now that Python 2 support is sunsetting. Python version changes and additions are relatively minor. What you learn now, especially with the Python language itself, will likely be the way to do things for awhile. This is not the case with all languages.  

Finally, the Python community is large, active, and welcoming. Many cities have regular Python-related MeetUp groups. You can find Python conferences around the world. The Python community is full of super-nice folks. These people have extended the language with libraries that have added all kinds of functionality.

## Suggested Uses
I suggest you use this book in one of two ways, depending upon your goals. If you want to get familiar with Python and won't be using the language every day, feel free to read this book quickly. Don't feel obligated to do the practice problems, quizzes, and explanations.

If you want to really learn to work with Python, I suggest you read the book in bite-sized pieces. Spacing out your learning will help the concepts, syntax, and code patterns stick. You won't remember nearly as much if you plow through it. You could read it once and then come back and read it again. You'll want to do all the practice problems, quizzes, and explanations. 

Configuration is often super frustrating when learning to code. And it's a brick wall that you might hit before you even get off the ground. 

![The Brick Wall of Configuration](images/brick_wall.jpg){#figcaption:brick_wall}

I'm so excited that you're able to avoid the configuration problem as you begin your Python learning journey. You can use any computer or Chromebook with a decent internet connection. 

## A Book Designed to Help You Learn
Here are the steps I've taken in the creation of this book to facilitate your learning.

Research shows it's best to learn something new by first working with a simplified version, even if you don't understand all the nuanced rules.[^1] Consequently, you'll be typing some things you may not understand. That's cool! I'll explain everything you typed. Then, you'll go deeper with the concept.

[^1]: This idea comes from [Making Learning Whole](https://www.amazon.com/Making-Learning-Whole-Principles-Transform/dp/0470633719) by David Perkins. Hat tip to [fast.ai](https://www.fast.ai/) creators Jeremy Howard and Rachel Thomas who introduced me to it. Once you have a year of coding under your belt, their courses can teach you deep learning with Python.

Second, I spiral the content. You won't just see a key concept and then never see it again. You'll revisit concept and syntax in later practice and quizzes. 

Third, I use images to help you anchor the content in space. Part of the reason ebooks are harder to learn from than physical books likely has to do with how our minds remember location-based content. In an ebook, it's much less intuitive where you are in the book, so it's harder to create memories.

Fourth, I include metaphors to help you understand and remember new concepts. Metaphors are fundamental to how we learn.

Fifth, I strive to provide clear, jargon-free explanations.  If something doesn't make sense, please let me know on [Twitter at discdiver](https://twitter.com/discdiver). 

Communicating a technical concept to someone who doesn't know it is difficult. It's hard to remember what it was like to not know related background information. This accidental assumption that you know related information is referred to as the [curse of knowledge](https://en.wikipedia.org/wiki/Curse_of_knowledge). It is a struggle for a writer to remember what it was like when they were learning the language. I tested this content with readers who were new to programming to overcome the curse.

Sixth, I provide content chunked into groups. An ordered, structured approach, with lists, is easier to recall than content strewn about.

Seventh, I judiciously excluded lots of stuff you don't need to know right now. Many intro guides try to be exhaustive and sacrifice memorability.

Eight, I include lots of code samples for you to type, not copy paste. I haven't provided a GitHub repo link for the code samples. Typing is more effective for learning. üòÅ

Ninth, I sprinkle in several different types of mnemonics throughout the book. A mnemonic is a mental trick you use to help you remember something. They are a pillar of efficient memorization. Acronyms, acrostics, and diddies are three types of memory aids.

- *Acronyms* ‚Äî A word where each letter stands for another word. For example, *NASA* for National Aeronautics and Space Administration.
- *Acrostics* ‚Äî A sentence where the first letter of each word stands for a different word you want to remember. For example, *My Very Educated Mother Just Served Us Nachos* for the planets: Mercury, Venus, Earth, Mars, Jupyter, Saturn, Uranus, Neptune.
- *Diddies* ‚Äî a rhyme with instructions. For example, to help you learn how to spell words with an *i* and an *e* next to each other, many schools teach the diddy "*i* before *e*, except after *c*". üéµ

The other day my daughter was singing a song about [Latin declensions](https://en.wikipedia.org/wiki/Declension) that her teacher taught her. Learning Python is a lot like learning a foreign language. You can benefit from diddies and other mnemonics, too.

Memorable Python provides a number of mnemonics ‚Äî some are goofy, some are pretty cool ‚Äî not all will work for you. Not all content has an accompanying mnemonic.  Go forth and make your own. Creating mnemonics makes the content you're learning easier for you to recall. 

Share them with me and the world on [Twitter at discdiver](https://twittter.com/discidver).  

Tenth, I expose you to key points multiple ways. How often do you remember something the first time you see it? Most people don't (although the chances go up if it's memorable). I help you cement your knowledge with practice, quizzes, and explanations.

Practice questions have you writing code, beyond the code samples in the book. It sounds funny, but it's true: actually coding is key if you want to learn to code. Students report far more success learning a technology when they actively code with it than when they passively view it. So code! ‚å®Ô∏è

At the end of most chapters I provide prompts for you to use to explain the concepts to others. Teaching someone else ‚Äî either through writing or talking about a topic ‚Äî is a phenomenal way to help you cement your understanding. If you can't explain something simply, you don't really understand it deeply.

Finally, in some chapters I'll subject you to a joke. Laughter helps you improve your mood, which helps you stay positive. And positivity helps you persist.

That's a bunch of ways this book is geared to help you learn. I hope you find them helpful! 

This book is designed to be read linearly, but  feel free to skip ahead if you have a section down cold. 

Remember, just reading this book is not enough if you want to really learn. Learning takes some wrestling. You will occasionally feel like quitting. That's normal. The struggle is part of the journey. Embrace it. 

You can do it!

## How Can I Contact You?
Find a mistake or something confusing? Help out your fellow readers by bringing it to my attention. ‚úã

Please let me know if you found something valuable, too. It helps me stay pumped up to untangle new technical content and make it accessible. üòÉ

[Twitter](https://twitter.com/@discdiver)

[LinkedIn](https://www.linkedin.com/in/-jeffhale)

Now let's get down to the business of learning Python. üëç

# Setup and Blast Off 

## Environment Setup
Python is a programming language. You type words, symbols, and letters in certain sequences with certain indentations. The Python interpreter then executes this code. If everything goes according to plan, your code runs to completion and does what you want. Yippee!

In this book you'll leverage a free resource to run Python on someone else's servers. In particular, we'll run Python on Google Colaboratory (Colab for short) for free. Colab uses Jupyter notebooks. 

If you know what you're doing and would prefer to run the code offline in your own environment or on another cloud provider, that's fine. For this book, I'm going to assume you're running a Jupyter notebook on Colab.

Jupyter notebooks are amazing tools to let you easily execute bits of code at a time. They have two types of cells: code cells where you write and run code, and Markdown cells where you communicate to your audience what you're doing.

You'll need an internet connection to run your code on Colab. Go to Google Colab in your web browser. The URL is [https://colab.research.google.com](https://colab.research.google.com). 

Make a Google account if you don't already have one. Then you can check out an [introduction to Colab on the site](https://colab.research.google.com/notebooks/welcome.ipynb#).

Create a new notebook by clicking on the *New Python 3 Notebook* link. 

## Start Coding
If you're reading this as an ebook I recommend setting up your monitor (or monitors) with a split screen, so that you have your Jupyter notebook on one side and Memorable Python on the other. Configuring your workspace for efficiency saves gobs of time. ‚è±

Type (don't copy and paste) the following code exactly as you see it below into a code cell in your notebook. Really do this. Copy-paste is a method for learning nothing. üòâ

You can add a new code cell by clicking on the *+ code* button on the top left of the notebook.

If the functions below are underlined in your Memorable Python book, that's fine. Just type the code and ignore the underline.

```python
my_word = 'fun'

if len(my_word) == 2:
    print("The string is two characters long.")
else: 
    print("The string is not two characters long.")
```

When you finish typing the code, click on the *play* button to the left of the cell to run the code in that cell. Hopefully you get the output below.

    The string is not two characters long.

Was typing the code slow and tedious? It can be for a while. The more time you spend typing code, the faster you'll become. Also, you can use a program such as [typing.io](https://typing.io/) to help you learn to type code faster.

### Dealing with Errors
If you try to run the code cell but got an error message, don't despair.

The good news is that most errors result in an error message and output that replays the steps that caused the error. This output is called a stack trace. The code you see in the trace is often not your code, but rather code other people wrote that you're leveraging. The bad news is that you likely won't have any idea what the error message is saying when you're first learning a programming language. üôä

Errors are very common. They happen to everyone. At first, errors can be frustrating, but as you get more familiar with Python, they become fewer. You'll also get faster at solving them.

Check out [this list](https://inventwithpython.com/blog/2012/07/09/16-common-python-runtime-errors-beginners-find/) of 17 common Python errors and their explanations. It's a great resource!

### Syntax Highlighting
Every time you have an opening symbol, such as the following: `(`, `{`, `[`, `"`, `'`, you need a closing symbol of the same type. Otherwise you'll get an error.

In Colab, characters that serve different purposes are in different colors. This is called syntax highlighting. It helps make your code easier to read and write. It will help you figure out when you have an open symbol without a closing symbol. üëç

### Keyboard Shortcuts
As you're going to be spending a lot of time typing, I suggest using that time as efficiently as possible. That means using your mouse or trackpad sparingly and keyboard shortcuts profusely. 

Here's where you can find guides to keyboard shortcuts:

- Colab ‚Äî in Colab go to the `Tools` menu -> `Keyboard Shortcuts` 
- [Chrome](https://support.google.com/chrome/answer/157179?hl=en)
- [Mac](https://support.apple.com/en-us/HT201236)
- [Windows](https://support.microsoft.com/en-us/help/12445/windows-keyboard-shortcuts)

I must warn you that Colab shortcuts don't quite match the usual Jupyter shortcuts. This is an annoyance and an [open GitHub issue](https://github.com/googlecolab/colabtools/issues/75). 

### Markdown cells
The *+ markdown* button at the top left of your notebook adds a new markdown cell. Markdown cells just include text and a bit of formatting to help you communicate. They don't affect your code. 

Markdown looks a lot like regular English. You can add headings with a pound sign *#* and a space. Smaller headings get two pound signs *##*. You can see a guide [here](https://www.markdownguide.org/getting-started). 

When you run a Markdown cell, the contents get converted from Markdown to formatted output.

Fun fact: I wrote this book using Markdown and a Jupyter notebook. üòÅ

### Saving
Save your notebook from the `File` menu or with a keyboard shortcut. It will be there next time you start Colab. 

Let's name this notebook. Click on the name of the notebook at the top of your browser window and name it whatever you like. Leave the *.ipynb* extension. That extension tells your computer that you have an IPython notebook file type ‚Äî that was the previous name for a Jupyter notebook.

### System version check
Now let's print information about the version of Python you're running. Enter the following code into a code cell (whenever you see code in this book, type that information into a Jupyter notebook code cell and run it).  

```python
import sys
sys.version
```

    '3.6.8 (default, Jan 14 2019, 11:02:34) \n[GCC 8.0.1 20180414 (experimental) [trunk revision 259383]]'

Your output should display a number that starts with 3. That means you're running Python version 3. Python follows semantic versioning. This  means the first number from the left is the major version, the second number is the minor version number, and the third is the patch version. You're fine if the number is 3.6.0 or higher. If the number is higher than 4.0.0, you probably need a new version of Memorable Python. üòÄ

Let's see what your code did. The Python interpreter imported the [*sys* module](https://docs.python.org/3/library/sys.html). This module comes bundled with Python and provides, "System-specific parameters and functions." We'll cover *import* statements in more depth later.

Then the `version` method returned information about the version of Python being used. Because the last line of code in the code cell caused some output, the output was automatically printed to your screen. That's a Jupyter notebook convenience. üëç

Behind the scenes, Jupyter inserted and ran the `print()` function on the last line of your code. We'll learn more about functions later in the book. For now, just know that  `print()` outputs whatever is in parentheses to the screen.

Now let's look at how you use numbers in Python.

# Numeric Literals and Variables
Type the following code to create your first *numeric literal* ‚Äî a number of some type.

```python
523
```

Run the code and you'll see the following output.

    523

Not that useful, but building blocks here, folks. üòÄ

Python has several principal built-in types. We're exploring numeric types first.

Let's use Python's built-in *type* function and pass it the argument *34*. 

```python
type(34)
```

    int

You get back *int*. That means your number is an integer data type. It's very handy to know how to get the data type of something in Python.

## Ints and Floats
Common numeric variables in Python are one of two types - either integers, denoted by *int* or floats, denoted by *float*. There are other types of numeric variables, but we're focussing on the most common ones here.

An int doesn't have a decimal part. 1 is an int. So is 0. So is -100.

Here's a little diddy to remember the name for integers in Python: *1, 2, and 3 are ints, you see.*

A float has a decimal part. 1.0 is a float. So is 0.0. So is -100.0002. 

### Integer Variables
Let's make an int.

```python
x = 1
```

Congratulations! You made a variable. Let's change its value.

```python
x = 2
```

Now `x` is 2.

Let's dig into what just happened.

Variables are fundamental to every programming language. A variable stores information. It has a value. A variable can be given a value when it is created. Or a value can be assigned to a variable later. 

A new value can be re-assigned to the variable. When you assign a new value the old value is gone. Forever. Bye, bye. üëã

You assign a variable with a single equal sign. Let's set a variable named *my_int* to the integer value 5.

```python
my_int = 5
```

Read this assignment as *my_int gets 5* instead of my_int equals 5. This is a trick to help you avoid a common error. As we'll see in a bit, a double equals sign `==` is used to test for equality between two things. 

Even experienced coders accidentally type a single `=` when they want a `==`. Single and double equals sign confusion are a pothole on the road to learning Python. Swerve around the potholes by thinking "*gets*" for assignment. 

Note that whether you have a space between the variable, the equals sign, and the value doesn't matter. Sometimes it matters if you have a space between things in Python. For assignment it doesn't matter. `x=10` is interpreted the same as `x = 10`. 

Run the one active cell you are typing in with the keyboard shortcut `‚åò` and `ENTER` on a Mac or (`Ctrl`) and `ENTER` on a Chromebook or Windows machine. Press the keys at the same time (you can hold down the `‚åò` key first).

Alternatively, you can run cells by going to the *Run* menu and selecting all or some of the cells to run. We'll take things one cell at a time in this book. üê¢

Let's verify the type of variable you just made by calling the built-in type function. I'll discuss functions later.

```python
type(my_int)
```

    int

You should see *int* for the output. 

When assigning a value to a variable remember the following.

- The variable name comes first. 
- Then the equals sign `=`.
- Then the value you want to give the variable goes on the right. 

You can assign a new value to the same variable the same way you assigned the original value.

```python
my_int = 10
```

Now the value of *my_int* is 10. 

### Floats
A number with a decimal value in Python is usually a `float`. Let's make a float. 

```python
type(5.0)
```

    float


```python
type(5.)
```

    float

Although `5` and `5.0` represent the same number, they are two different variable types. You can even shorten `5.0` to `5.` and create a float. All you need is the period.

Close your eyes in a moment and make the following image in your mind. Picture a dot floating on the sea to help you remember that `float` refers to a decimal value.

## Summary
 Alright, you're on your way! Keep rolling! 
 
### Recap
Remember `=` is used to assign a value to a variable. 

Think *gets* when you see `=`.

Diddy: 1, 2, and 3 are *ints* you see.

## Practice
1. Make an integer variable.
2. Make a float variable
3. Get the type of a numeric value.
4. Get the type of a numeric variable.

## Explain
1. Write or explain to someone what a variable is and how it differs from a value.

#### Terms to know
- Values
- Variables
- Int
- Float

# Math Operations
![Fortunately you don't need to use an Abacus](images/abacus.jpg){#figcaption:abacus}

Let's do some math with our floats and ints. 
## Addition
First, let's add two integer literals together.

```python
7 + 34
```

    41

Now let's do the same thing with integer variables.

```python
first_int = 7
second_int = 34
first_int + second_int
```

    41

There's some addition.

```python
third_int = first_int + second_int
type(third_int)
```

    int

The two integers were added together and the result was saved in `third_int`. Passing `third_int` to the built-in type function returns `int`. So adding two ints together results in an int. That makes sense.

What happens if you add an int and a float together? What variable type do you think will be returned?

```python
3 + 4.9
```

	  7.9

```python
type(3 + 4.9)
```

	  float

Adding a float and an int results in a float. That makes sense, too. If an int were returned we'd lose the decimal information.

Notice that the line of code above has several parts. First, the Python interpreter evaluates the operation in parentheses, so it adds 3 and 4.9. Then calls the `type()` function. Finally, it prints the result of the call to the `type()` function.

## Subtraction
Subtraction works similarly to addition.

```python
7 - 34
```

    -27

```python
first_int = 7
second_int = 34
first_int - second_int
```

    -27


```python
first_int = 7
first_float = 34.2
first_int - first_float
```

    -27.200000000000003

## Multiplication
Multiplication uses the asterisk `*` symbol. 

```python
7 * 34
```


    238


```python
first_int * second_int
```


    238

In Python, it doesn't matter if there is a space between the mathematical symbol and the number or variable in terms of how the program behaves. But for readability, it's customary to have a space on both sides of the symbol.

## Division
Regular division uses the front slash symbol `/`. What type of number do you think you'll get back if you divide one int by another evenly? Let's check.

```python
25 / 5
```

    5.0

```python
type(25 / 5)
```

    float

If you answered *float* you're correct! That's a bit of a surprise, don't you think? The result of regular division with two ints is a float. 

Here are some more division examples.

```python
7 / 34
```

    0.20588235294117646

It makes sense that you would want to have access to this decimal information, so integer division always results in a float.

```python
first_int / second_int
```

    0.20588235294117646

```python
28.1 / 7.2
```

    3.9027777777777777

Now let's look at a type of division that might be less familiar to you.

## % Modulo Division 
The percent sign is used for modulo division. Modulo division returns the remainder.

```python
34 % 7
```

    6

If you remember your math, 34 divided by 7 equals 4 remainder 6. 

```python
second_int % first_int 
```

    6

Main thing to remember: the percent sign % means *remainder*. 

Here's a little diddy to help your remember.

*Oh, oh, modulo, 
You just get what's leftover, you know?*

Say it in your head with a sing-song voice. Bonus points if you record yourself doing it and share it online. üòÅ

Modulo's counterpart is floor division.

## Floor Division //

Floor division is symbolized by `//`. Floor division rounds down to the largest integer.

```python
second_int // first_int
```

    4

Let's check the type of the number returned.

```python
type(second_int // first_int)
```

    int

That's different than the behavior you saw with regular division between two integers that resulted in a whole number. With regular division between two integers a float was returned.

Regular division always returns a float. Floor division returns whatever data type the numbers had prior to the floor division operation.

```python
float_one = 10.01
float_two = 4.9
```

```python
float_one // float_two
```


    2.0

In the case where one of the two original variables is a float, the result of floor division is a float.


```python
11 // 5.0
```


    2.0

Main thing to remember: double backslash // means *floor division*. 

*Floor = Ignore* the remainder. 
Another way to remember: regular division `/` cuts down the number. Floor division cuts it twice, once for each slash  `//`. First you divide like normal, then you chop off the remainder.

![Knife for chopping](images/knife.png) 

## Exponents
The exponent operation symbol is a double asterisk `**`.

```python
3 ** 2 
```


    9

In English, this is the same as saying *three to the second power*.

```python
float_one ** second_int
```


    1.0345670306556055e+34


```python
10 ** 2.0
```


    100.0

If two ints are used, then an int will be returned. If a float is involved, the returned value will be a float. 

The main thing to remember: double asterisk `**` means exponent. 

You can remember this symbol by recalling that a single asterisk with two positive numbers both greater than one makes a bigger number. A double asterisk with two positive integers greater than one makes an even bigger number. 

In general, more asterisks means bigger number. 

## Order of Operations
The order of operations from first to last is the following:

parentheses, exponents, multiplication, division, addition, subtraction.  

Use the acrostic **PEMDAS**. You might have seen it before.

P - parentheses\
E - exponents \
MD - multiplication and division (left to right) \
AS - addition and subtraction (left to right)

Parentheses have the highest precedence. 

Then exponents.

Then multiplication and division have the same precedence, so which ever comes first from left to right gets executed first.

Floor division and modulo division are included in the multiplication and division category.

Finally, addition and subtraction come last. They have the same precedence as each other, so whichever operation comes first gets executed first.

Now let's look at a few shortcut operators.

## Assignment Operators
Let's look at `+=` first. We'll name our variable `count`.

```python
count = 0
count += 10
count
```


    10

The assignment operator first does the mathematical operation and then assigns the value back to the variable. So in this case, `count` starts with a value of 0 and then gets 10 added to it. At the end of the code cell `count` has the value 10. It will have that value at the start of the next code cell, too.

To remember that the `+` comes before the `=`, think ADD then ASSIGN. 

ADD comes before ASSIGN, alphabetically, so that might help you keep the order straight.

There is an assignment operator for each of the mathematical operations listed above. Just put the symbol for the operation you want before the equal `=` sign.

```python
count /= 2
count
```

    5.0

Just as before, dividing two ints results in a float being returned.

```python
Count = 3
count **= count
```

```python
count
```


    3125.0

Note that to display the output in the Jupyter notebook you need to put the variable name on a separate line. Jupyter won't display the result of an assignment operation by default.


```python
count *= 2
```

See, no output.


```python
count
```


    6250.0

Now, you get output.

Note that there are no increment or decrement operators in Python (`++` or `‚Äî`), as there are in some other programming languages. 

## Type Conversion
Python functions can automatically convert a variable type to another. This process is called *implicit type conversion*. You saw it previously when dividing two ints returned a float. 

You can also use *explicit type conversion* to change the type of a variable.

If you want to make an int into a float, you can do so like this:

```python
float(5)
```

    5.0

You can go the other direction, from float to int, like this:

```python
int(5.6)
```

     5

Note that the decimal gets rounded down to the nearest integer when you convert from a float to an int.

## Summary
You've seen a bit of what you can do with numeric values and variables in Python. Cool.

### Recap

#### Mathematical operators
* `+`
* `-`
* `/`
* `*`
* `//`
* `%`
* `**`

#### Order of operations:
PEMDAS

#### Assignment operators
* `+=`
* `-=`
* `/=`
* `*=`
* `//=`
* `%=`
* `**=`

#### Type conversion
* float(3)
* int(2.6)

## Practice
1. Make a variable and set it to 100.
2. Divide the variable by itself using regular, modulo, and floor division.
3. Return the type of the variable.
4. Assign a new value to the variable.
5. Make a float and use the exponent operator with it.

## Quiz
1. What's a value?
2. What does the `%` operator do?
3. What does the `//` operator do?
4. How do you increase a variable by 20 and assign the new value back to the original variable?
5. What's the difference between a float and an int?

## Joke Break
*I used to be addicted to the hokey pokey...*

but I turned myself around.

# Efficient Learning 
Learning Python means remembering concepts and syntax.

To learn something you focus to encode it into short-term memory. Most things in short-term memory are forgotten quickly. Consolidating what you've learned into long-term memory requires multiple cycles of retrieving the thing you are trying to cement. You are actually rewiring your brain, strengthening connections between synapses. This is is a process that takes some time. It's also a process that you can make more efficient. 

## Learning tips
You'll remember more if you do the following things:

1. Devote focussed blocks of time to Python learning. Visual and auditory distractions make it difficult to encode memories. You can reduce them finding a quiet place to work or using white noise or calm classical music.
2. Take breaks. The Pomodoro method of timed focus followed by breaks is one that many programmers love. There are many apps to implement the method. [TomatoTimer](https://tomato-timer.com/) is an easy to use website that does the job.
3. Study sober. Unfortunately, alcohol isn't a study aid. üòâ
4. Sleep well. You don't consolidate your memories well if you don't sleep well. This means sleep both enough and consistently. Ideally, train yourself to wake up without an alarm. Use a white noise app to help block out distracting noises to improve your ability to stay asleep. Avoid alcohol the night after studying - sorry to be a party pooper twice, but alcohol interferes with sleep. üò¥
5. Meditate to improve your ability to focus. When you focus better, you learn better. [Headspace](https://www.headspace.com/headspace-meditation-app) is a popular app to help you get started.
6. Don't just sit there. You learn better when you move. Not to mention, if you're sitting all day, it is literally killing you. The research is indisputable. Full disclosure, I co-founded treadmill desk company [Rebel Desk](https://rebeldesk.com) with my spouse in 2012 to help people be healthier, happier, more productive.
7. Relatedly, when you take a break, do something physical instead of looking at a screen. Go for a walk, do some pushups, or play some ball. If you can, get outside into nature. Exercise and the outdoors are great for clearing your mind. They put you in a better mood, too. A can-do attitude is key to learning to code, because there will be frustration on the journey. üëü
8. Take your own notes and quiz yourself on them just before you'd forget the material. Following a spaced repetition system (SRS) is a proven way to help you learn faster. [Anki](https://apps.ankiweb.net/) is a free flashcard-type app for SRS.

Now you know strategies that will help you learn. If you adopt those strategies, that's by far the most valuable thing you'll get out of this book. Those strategies can change your life. Speaking of strategies, let's look at strategies to help you stick with learning to code.

## Commit and Plan
Achieving mastery requires deliberate practice. Deliberate practice means sustained attention over time. There are a variety of strategies that you can put in place to help you stick with your Python practice.

First, commit to reading one page of this book every day. You can do one page, right? A single page only takes a few minutes It's short and easy.

This is a microhabit. Microhabits help you overcome the "getting out the door" problem.

Once you start reading one page, it's easy to go further. You've tricked yourself into developing a habit of getting stuff done. Clever. üòâ

Second, make your commitment to learn Python public. You're more likely to follow through with something if you make it public. Tag me on [Twitter at discdiver](https://discdiver.com) if you want me to know you've committed. This is a tip from [Switch](https://heathbrothers.com/books/switch/), a great book on behavior change.

Third, schedule time on your calendar for daily Python practice. Treat it like a real appointment. You can schedule a repeating event right now. üìÜ

Now that you've seen memory tips and made a deliberate practice plan, let's get back to the coding. üêç

# Comments and Spacing
The pound sign `#` denotes a comment. Here's a comment.

```python
# my first comment
```

Here's another comment on a line that also contains some live code. 

```python
x = 100   # my second comment
x
```

Everything that follows the `#` symbol on that line gets ignored by the Python interpreter. For clear style, include a blank space between the pound sign and the start of your comment. 

Comments provide additional information to the reader. Regular Python programs contain comments for communication. Jupyter notebooks have Markdown cells for communication, so comments are less necessary.

Running a Markdown cell in a notebook converts the contents into the finished Markdown product. The output is just fancy text. The Python interpreter doesn't run anything in a Markdown cell so your variables and the rest of your code are unaffected by them.

Comments are also helpful when you want to turn off some code and exclude it from running. Maybe you want to debug your code or refactor it into better code.

Here's an example of commenting over several lines. 

```python
# I did this to explain my thinking. 
# This was a longer point so I commented on several lines. 
# Then I commented out my code.
# my_code = 3 + 1
# my_code
```

There are also multiline comments at the start of user-defined functions and classes. They are enclosed in triple double quotes `"""`. I won't go into those now.

## Whitespace
Some whitespace gets ignored by the Python interpreter. For example, you can include all the extra blank lines you like. Same goes for extra spaces at the end of a line. No big deal. 
 
However, a space in the wrong place can break your code. 

The function calls below would break your code because they have an extra space where there shouldn't be one.

```python
my_object. my_function()
my_object .my_function()
len ("mystring")
```

Also, indentation matters a great deal in Python. I'll cover indentation with control flow statements. For now, just keep all your code unindented, with no spaces at the start of the line.

The more you code in Python, the more the spacing rules become second nature. Don't get discouraged if they trip you up at first. üòÄ

## Summary
Comments and whitespace both affect how your code runs.

### Comments
- Comments start with a  `#`. 
- Everything after the `#` gets ignored.
- Comments are useful for conveying information.
- Comments are a quick way to turn off a piece of code without deleting it.

### Whitespace 
- Python doesn't care about blank lines or extra spaces at the end of a line.
- Python also doesn't care about empty spaces between mathematical operators.
- A blank space can break your code in some situations - I'll point many of those out as we go.  
- Don't indent your code yet. I'll discuss indentation in a bit. 

## Practice
1. Make a comment.
2. Divide one int by another and assign the result to a variable.
3. Check the type of the variable.
4. Floor divide one int by another and assign the result to a variable.
5. Check the type of the variable.

## Quiz
1. Why don't you need as many comments when you are using a Jupyter notebook?
2. What does `%=` do?
3. If you have a blank line in your code, will it affect how your code runs?

## Explain
1. Explain to someone what a comment is and when they might want to use one.

# Strings
[Strings](https://docs.python.org/3/library/stdtypes.html?highlight=int#text-sequence-type-str) are a text sequence type. 

For example, "Hi how are you today?" is a string. So is "h". Strings are enclosed in quotes - either double quotes "like this" or single quotes 'like this'. Either way is fine, just make sure your opening and closing quotes are the same type!

![Strings](images/string.jpg){#figcaption:string}

## String Details
`'a'` is a string.

`"5"` is a string. 

A number in quotes is a string because it's in quotes. If `5` were not in quotes it would be an int.

Think *quotes `""` means string*.

Here's a little diddy to say out loud:

*"red's" a string, \
"blue's" a string, \
they both have quotes around the thing.*

Declare an empty string variable with no spaces between the quotes.

```python
alpha = ""
alpha
```

    ''

`alpha` is set to an empty string. Let's set `beta` to a space.

```python
beta = " "
beta
```


    ' '

An empty string and a space are different values! That space is something ‚Äî it's definitely not nothing.

## String Type Conversion
If you want to explicitly convert a value or variable to a string you can do so like this.

```python
my_var = str(5)
type(my_var)
```

	  str 

## Working with Strings

### Add two strings together with a plus sign `+`.

```python
"one string " + ", two strings"
```

    'one string , two strings'

You can concatenate more than two strings the same way.

```python
"one, " + "two, " + "three"
```

    'one, two, three'

## String Methods
Strings have a number of built-in functions, called methods. Technically, a method is a function of a class. We'll talk about functions and classes in more detail later. There are many built-in string functions you're unlikely to use. Here are common ones I suggest you learn.

**Split**
- split

**Case change family.** 
- upper
- lower
- title

**Strip family.**
- strip
- rstrip
- lstrip

**Replace**
- .replace(old, new)

Let's make a string and explore these string methods. üßµ

```python
my_string = " The little green truck went 'Beep, beep, beep!' Funny. "
```

Notice the string you made has extra spaces at the beginning and end, inside the quotes. These extra spaces are whitespace.

### split()
Create a list of substrings with `split()`. 

```python
my_string.split()
```


    ['The',
     'little',
     'green',
     'truck',
     'went',
     "'Beep,",
     'beep,',
     "beep!'",
     'Funny.']

Split returns a list of strings. We'll get to the list data structure soon.

![Split](images/split.jpg){#figcaption:split}

By default, split divides the string at each space and discards the space. 

Alternatively, you can split on a character of your choice. Just pass the character to `split()` on as the first argument. That means put the character inside the parentheses. We'll dig into functions and arguments later. 

Let's split on commas. 


```python
my_string.split(',')
```


    [" The little green truck went 'Beep", ' beep', " beep!' Funny. "]

Make sure the character you pass is in quotes so it gets recognized by the interpreter as a string literal and not a variable. 

Here's one more example that splits on the letter *e*.


```python
my_string.split("e")
```


    [' Th',
     ' littl',
     ' gr',
     '',
     'n truck w',
     "nt 'B",
     '',
     'p, b',
     '',
     'p, b',
     '',
     "p!' Funny. "]


Not sure why you'd want do that, but you can! 

Again, note that the value you split on gets excluded from the returned list of strings.

### Case change family
There are several built-in string methods to change the case of words.

#### upper()
Uppercase each letter with `upper()`

```python
my_upper_string = my_string.upper()
my_upper_string
```


    " THE LITTLE GREEN TRUCK WENT 'BEEP, BEEP, BEEP!' FUNNY. "

#### lower()
Lowercase each letter with `lower()`.

```python
my_lower_string = my_string.lower()
my_lower_string
```


    " the little green truck went 'beep, beep, beep!' funny. "

#### title()
Capitalize the first letter of each word with `title()`.

```python
my_title_string = my_string.title()
my_title_string
```


    " The Little Green Truck Went 'Beep, Beep, Beep!' Funny. "

Notice that this isn't true title case. All words get capitalized, including words that should not be capitalized in a title.

### Strip family
There are several functions for stripping whitespace. 

#### strip()  
Remove whitespace on the outside of both sides of a string with `strip()`.

```python
my_stripped_string = my_string.strip()
my_stripped_string
```

    "The little green truck went 'Beep, beep, beep!' Funny."

Now there's no extra whitespace at the start or end of the string.

Think "`strip()` strips whitespace".

#### rstrip()  
Remove whitespace on the right side of a string with `rstrip()`.

```python
my_right_stripped_string = my_string.rstrip()
my_right_stripped_string
```

    " The little green truck went 'Beep, beep, beep!' Funny."

#### lstrip()  
Remove whitespace on the left side of a string with `lstrip()`.

```python
my_left_stripped_string = my_string.lstrip()
my_left_stripped_string
```

    "The little green truck went 'Beep, beep, beep!' Funny. "

The *r* and *l* at the start of the method names are intuitive for *right* and *left*.

### Replace part of a string
Replace part of the string with `replace()`.

```python
replaced_string = my_string.replace('Beep', 'Hug')
replaced_string
```


    " The little green truck went 'Hug, beep, beep!' Funny. "

Notice that only 'Beep' was replaced, not 'beep'. `replace()` is case sensitive.

There are often many ways to accomplish the same thing in Python. 

Use whatever way works for your first pass. Then, when you want to improve your code to make it easier for other people to understand or make it faster, you can alter it.

*Regular expression* matching ‚Äî Regex for short ‚Äî is a powerful way to search for string matches. I won't dive into Regex in this book, but [here's](https://regex101.com/) a useful website for testing and referencing regular expressions.

## Summary
The ability to manipulate strings is a valuable Python skill.  

`split()` and `strip()` can be a bit confusing to keep straight because they sound similar. 

Split splits a sentence into individual words. 

Strip strips off whitespace. 

Practice common string methods till you have them down.

### Recap
Add two strings with `+`.

- `split()` ‚Äî separate a string into a list of substrings.

- `strip()` ‚Äî remove whitespace
- `rstrip()` ‚Äî remove whitespace on the right
- `lstrip()` ‚Äî remove whitespace on the left

- `upper()` ‚Äî make every letter uppercase
- `lower()` ‚Äî make every letter lowercase
- `title()` ‚Äî make the first letter of every word uppercase

- `.replace(old, new)` ‚Äî substitute the new value for the old one 

We'll show you how to do more string manipulation later. 

## Practice
1. Make a string variable that contains a sentence. 
2. Use a string method to change the case of the text. 
3. Then split it based on whitespace.  
4. Make an f-string with the name of your favorite person.
5. Raise 7 to the 3rd power.

## Quiz
1. What do you call the variable type of a simple decimal number?
2. How can I change the value that split splits text on?
3. How are string slicing, `strip()`, and `split()` different from each other?
4. What does `title()` do?
5. How can you add two strings together?

## Explain
Explain what a string data type is.

## Joke Break
*Why shouldn't you buy anything with velcro?*

Because it's a total rip-off.

# Getting Help
One of the primary goals of education is to make the teacher superfluous. 

How can I help make myself obsolete? I can show you what to do when you need help. üòÅ

My first piece of advice is to search Google with your question quickly.

You might get back a link to the [Python docs](https://docs.python.org/3/). Don't feel bad if the docs feel like ancient Greek. The docs do have lots of good information, but it can feel like overwhelming jargon when you're starting out. 

[Stack Overflow](https://stackoverflow.com/) (SO) is likely to show up in your search results. Stack Overflow answers are often particularly helpful when you have an error messages.

Make sure you follow [the Stack Overflow guide](https://stackoverflow.com/help/how-to-ask) and do your research before asking a question. Redundant questions will be downvoted. Do use Stack Overflow if you get stumped with a programming problem.

The [Real Python](https://realpython.com/) website is a great resource for in-depth guides to Python topics. 

Bottom line, self-serve yourself a bowl of help by Googling early and often. In the next chapter we'll see what's True and what's False. ü•£

# Booleans

[Boolean](https://docs.python.org/3/library/stdtypes.html?highlight=int#boolean-values) variables can take the value `True` or `False`.  

```python

type(True)

```

    bool

Make sure you capitalize `True` or `False`. Otherwise you've created a string and not a boolean.

You can set a variable directly to `True` or `False`. Or, if you compare two variables with a comparison operation the return value will either be `True` or `False`.

## Comparison Operations

`0`, `False`, and the special value `None` evaluate to `False`. All other values evaluate to `True`.

Python has eight [comparison operations](https://docs.python.org/3/library/stdtypes.html?highlight=int#comparisons), six of which are useful when you are comparing two variables.

Test for equality with a double equals sign `==`.

 ```python
6 == 12
```


    False

Yep, 6 doesn't equal 12.

 ```python
12 == 12
```


    True

Yep, 12 equals 12.

```python
your_number = 6
my_number = 12

my_number == your_number
```


    False

That result makes sense.

```python
my_number / 2 == your_number 
```


    True

That makes sense, too.

Remember to watch out for single and double equals sign confusion. The single equals sign is for assignment, not comparison. 

Here's the *less than* `<` comparison operator in action:

```python
4 < 5
```


    True


Here's *greater than* `>`.


```python
4 > 5
```


    False

And now *greater than or equal to* `>=`.

```python
5 >= 4
```


    True

Notice that the *greater than* part of the sign comes before the *equal to* part of the sign.


```python
4 >= 4
```


    True

Now *less than or equal to* `<=`.


```python
4 <= 5
```


    True


```python
6 <= 5
```


    False

The *not equal to operator* `!=` might be less familiar. It returns the opposite result of `==`. It returns `True` if the values compared are not equal and `False` otherwise.


```python
4 != 4
```


    False


```python
4 != 5
```


    True

Remember `!` stands for *not*! Visualize a child yelling "Not!" to help you recall the meaning.

That's it for comparison operations. Now let's look at boolean operations.

## Boolean Operations

The three boolean operations are `or`, `and`, and `not`. 

The `and` operation tests two conditions in one line of code. Both conditions must be true for it to return `True`.


```python
4 > 4 and 4 < 5
```


    False

Four greater than four AND four less than five. Nope. That's false.


```python
4 > 3 and 4 < 5
```


    True

Four greater than three AND four less than five. Yep. That's true.

The `or` operation also tests two conditions. However, only one condition needs to be true to return `True`. If both conditions are true, it will also return `True`. If both conditions are false, it will return `False`.

```python
4 > 4 or 4 < 5
```


    True

Four greater than four is false, but four less than five is true, so it returns `True`.


```python
4 < 4 or 4 > 5 
```


    False

Four less than four is false and so is four greater than five, so it returns `False`.

Finally, we have the `not` operation.

### not
The `not` operation switches the result of the evaluation that would otherwise be returned. It is used a bit differently than *and* and *or*. See below.


```python
not 5 > 7
```


    True

Without the `not`, 5 > 7 would evaluate to `True`. But the `not` operation switches that `True` to `False`.

### Multiple boolean operations
When you see two or more boolean operations together, things can get confusing.

Here's the precedence order:

- `not` binds tighter than `or` and `and`
- `and` binds tighter than `or` 
- `or` is loosest

```python
5 < 6 and not 5 > 7
```


    True

It can be helpful to think of the expression above with parentheses. Here's a way to visualize how it's evaluated.

```python
(5 < 6) and (not 5 > 7)
```


    True

`not` gets applied first because it binds closest. 

To keep the order that boolean operations bind straight you can think of the following:

*Nice Aardvarks Only* 

for *Not And Or* üòÅ

## Summary 
We had lots of fun this chapter ‚Äî True or False? 

Numbers, strings, and booleans are basic, elemental data structures in Python. You can think of these variables  as small containers. 

### Recap

`True` and `False` are boolean values. They are always capitalized. 

#### Boolean comparison operators 
`>` greater than
`<` less than
`==` equal to
`>=` greater than or equal to
`<=` less than or equal to
`!=` not equal to

### Boolean operations
`or` ‚Äî one must be true
`and` ‚Äî both must be true
`not` ‚Äî switches what the result would be

## Practice
1. Set two numeric variables to boolean values.
2. Compare them to each other.
3. Compare uppercase and lowercase letter "A" to each other with `>`. Which do you think is going to be evaluated as greater than the other?
4. Use `and`, `or`, or `not` with boolean comparisons and numeric variables. For example (y > 3 and not x < 4)

## Quiz
1. In a line with the boolean operations `and`, `or`, and `not` which gets applied first?
2. How do you check if one variable is less than or equal to another variable?
3. What does `\\` do?
4. What value can a Boolean variable type have?
5. Is this a legal variable: `8_car`?

## Explain
Explain to someone else what a Python Boolean variable type is.

## Joke Break
*Why couldn't the bicycle stand up by itself?*

It was two tired. üö≤

# Variable Names
Python variable names should be lowercase and start with a letter. They can also begin with an underscore, but at this stage, start them with a letter.

Python is case sensitive. A variable named with a capital *X* is a different variable than one named with a lowercase *x*.

Variables should be descriptive and as short as possible while still clearly conveying their purpose. Deciding what's too short is a judgement call. Generally, error on the side of being more verbose. 

Multiple words should be joined with an underscore. This is sometimes "called snake case". Perfect for Python. üêç

`car_counter` is a good variable name. 

`c_c` is not.

Code gets read many times more than it gets written. It's good to develop good habits now. Your future self will thank you, because it's hard to remember what you were thinking months after you write a piece of code.

Python keywords need to be avoided for variable names.  Here are the 33 reserved keywords:
 
*and, as, assert, break, class, continue, def, del, elif, else, except, False, finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return, True, try, while, with, yield*

You should also avoid naming your variables with common words that could collide with the names of imported variables. Avoid names that sound like they could be mathematical operations or programming concepts. 

Knowing which words to avoid can be a bit tricky until you've worked with the language for a while. I suggest that you avoid naming a variable anything that is an important word in this book. 

For clarity, the official [Python style guide](https://www.python.org/dev/peps/pep-0008/#id38) ‚Äî recommends avoiding the following single characters: 

> Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names.

> In some fonts, these characters are indistinguishable from the numerals one and zero. When tempted to use 'l', use 'L' instead.

When in doubt, error on the side of avoiding a possible collision and strive for clarity.

## Constants
A constant is a value that you don't expect to change. For example, you might want to use the exact number of days in the year in your program. 

```python
DAYS = 365.2422
```

Constants are all caps, by convention. 

Note that constants aren't are just regular variables to the Python interpreter. You're just signaling to other readers of your code that the value of the constant shouldn't be changed by some other piece of code. 

It's convenient to define a constant instead of typing the same value a bunch of times. It's especially nice when you decide you want to use a different value instead. Now you only need to change the value in one place!

## Summary 
You've seen how to stay out of trouble with your Python variable names. You've also seen naming conventions for constants.

Just remember, *clarity over brevity*.

# Lists

*Lists* in Python are similar to the common English meaning of lists. 

## List Details
Lists are ordered data structures. 

This is a Python list:

```python
my_int_list = [5, 2, 3, 8, 2]
my_int_list
```


    [5, 2, 3, 8, 2]

So is this:

```python
my_second_list = ["I like", "to run", 1, True]
my_second_list
```

A list contains values. The values can be of any type. You could have a list of strings, ints, floats, booleans, other lists, or some other variable type. The values don't all have to be of the same type, but they often are. 

## Using Lists

### List creation
Lists can be created by putting square brackets `[] ` around some values. Each value is separated by a comma. 

You make an empty list like this:

```python
my_empty_list = []
my_empty_list
```

    []


```python
type(my_empty_list)
```


    list

That list has nothing in it. But it's ready to have items added to it. 

You can think of a list as a container with dividers, such that each item is at a location with a number, starting from 0. 

List items remain in the order you inserted them into the list ‚Äî unless you act on them to change that order.

üì£
BEEEEEEEEEEP! BEEEEEEEEEP! BEEEEEEEEEP!
We interrupt this riveting content for a public service announcement:

 Remember that you'll get much more out of this book if you're typing each piece of code by hand and running it. 
 
 End of public service announcement. We now return to your regularly scheduled content. üòÄ

### Return a list item
You'll often want to get an item from a list, based on its position in the list. Let's make a list of strings look at how to do that.


```python
my_str_list = ['hi', 'how', 'goes']
my_str_list
```


    ['hi', 'how', 'goes']

List items start to be inserted at position 0. Each additional list item is inserted into the list at a position that is one greater than the previous position. So the second list item is inserted at position 1.

0-based indexing is the norm in programming, but it can be confusing if you aren't used to it. We've been trained to think of the first item as corresponding to the number 1. 

For programming, you just need to practice and repeat and memorize so that you remember: "The first item is at index position 0 and the second item is at index position 1 and so on.

Access a list element based on its index position. 

```python
my_str_list[0]
```


    'hi'

You returned the item at index position 0 by typing the name of the list immediately followed by the number in square brackets. Notice there were no spaces anywhere.

Let's get the second list element from index position 1.


```python
my_str_list[1]
```


    'how'


What if you want to get the last item in the list?

You can access a list item from the end of the list by counting backwards with a negative number. So -1 will give you the last list element. 

```python
my_str_list[-1]
```


    'goes'

`[0]` is the beginning item, so it makes sense that [-1] would be the first item from the other side of the list.

`-2` will return the second to the last list item. And so on.

```python
my_str_list[-2]
```


    'how'

## List Slicing
Access a subgroup of list elements with a colon between the starting index and the ending index. Notice that the ending index number is NOT inclusive. 


```python
my_str_list[0:2]
```


    ['hi', 'how']

Notice that only the elements at index 0 and 1 are returned as a list. The element at index 2 is not returned!

```python
my_str_list[0:3]
```


    ['hi', 'how', 'goes']

The starting 0 is optional. The code above is equivalent to the following. 

```python
my_str_list[:3]
```


    ['hi', 'how', goes]

Read this slice as "everything up to index 3".

If you see a colon by itself before a number, read it as "up to".

If you want to return all the items starting from an index, put the colon after the number. Like this:

```python
my_str_list[1:]
```


    ['how', 'goes']


Similarly, you can get the values from the specified index through the end of the list with a negative number and a colon `:` like this:

```python
my_str_list[-2:]
```


    ['how', 'goes']

Read this as "From the second last item to the end of the list".

List slicing can get confusing, so make sure you practice it a bunch! ‚å®Ô∏è

## List Manipulation

### Change a list value
You can alter a value in a list by referencing its index and assigning a new value to it with the usual assignment operator, the `=` symbol.


```python
my_str_list[0] = "Fun"
my_str_list
```


    ['Fun', 'how', 'goes']

### Combine lists 
Combine two lists with `+`.

```python
my_str_list + my_int_list
```


    ['Fun', 'how', 'goes', 5, 2, 3, 8, 2]

The list on the right side of the `+` symbol gets concatenated (fancy word for "added on") to the items on the left.

There is another way to concatenate lists, but I find `+` much easier to remember, and we're trying minimize the number of things to remember. üëç

### Reverse a list
You can reverse a list with two colons followed by -1 `[::-1].


```python
my_str_list = my_str_list[::-1]
my_str_list
```


    ['goes', 'how', 'Fun']

There's a method to do this also. However, you'll see this way to reverse a list quite often. 

### Return the number of items in a list
`len()` returns the number of items of a data structure. In the case of a list, it return the number of items.


```python
len(my_str_list)
```


    3

Note that this function isn't a list method. It goes to the left of the item who's length you want.

Think **len() on the left**.

![Measure the count with len()](images/tape_measure.jpg){#figcaption:tape_measure}

### Sort a list
You can sort a list by passing the list to `sorted()`.

```python
sorted(my_str_list)
```


    ['Fun', 'goes', 'how']

`sorted()` returns a sorted list. This method works with other data structures, too. There is another method that sorts lists in place `my_list.sort()` ‚Äî but [my tests](https://towardsdatascience.com/surprising-sorting-tips-for-data-scientists-9c360776d7e) found it to take longer. They use the same algorithm under the hood. It's not worth trying to remember two ways to do the same thing. 

`sorted()` and `len()` are similar in that they both have the list passed to them as arguments. They both work with several types of data structures.

Remember `sorted(my_list)`.

```python
sorted(my_str_list)
```


    ['Fun', 'goes', 'how']

## List Methods
The following are true list methods only available to lists. They all follow the syntax `my_list.method_name()`.

### append()
Add a new item to the end of a list with `append()`.

```python
my_str_list.append("it")
my_str_list
```


    ['goes', 'how', 'Fun', 'it']

Like other list methods, notice that `my_str_list` gets altered in place. In other words, it gets mutated. 

### insert()
Insert an item into a list at the specified location.

```python
my_str_list.insert(1, "dog")
my_str_list
```


    ['goes', 'dog', 'how', 'Fun', 'it']

`"dog"` is inserted at position 1. Remember that the index location comes before the item being inserted. Place before thing.

### remove()
Remove the first instance that matches the specified value with `remove()`.

```python
my_str_list.remove('how')
my_str_list
```


    ['goes', 'dog', 'Fun', 'it']

### pop() 
Take the last item in the list and return it. The list is altered.

```python
my_str_list.pop()
```


    'it'

```python
my_str_list
```

    ['goes', 'dog', 'Fun']

You can specify a location in the list with `pop()` if you want to remove an item and have it returned to you.

## Summary

Lists are powerful and very common. When you want ordered data, you generally want a list.

### Recap
When you think list, think square brackets `[]`.

#### Returning list values

Access the a list item with `my_list[4]`. 

Zero based indexing means you get back the fifth list item with `my_list[4]`.

Access the list value that's second from the end with `my_list[-2]`

Access a group of list values with a colon `:` `my_list[2:5]`. Remember that the last number is not inclusive. So this example would return three items: the third, fourth, and fifth.

Use `[:5]` to return the first four items and `[5:]` for the fifth item to the end of the list.

### Common list methods

- Combine lists with `my_first_list + my_second_list`
- Reverse a list with `my_list[::-1]`
- Sort a list with `my_list.sorted()`
- Count the number of elements in a list with `len(my_list)` 

Remember that my_list gets passed as an argument to `len()` and `sorted()`. 

Add items:
- `my_list.append()` append an item to the end of a list
- `my_list.insert()` insert an item at a specific location

Get rid of items:
- `my_list.remove()` remove an item at a specific location
- `my_list.pop()` remove the last item and return it


## Practice
1. Make a list of numbers.
2. Insert a number in the second position (you_list[1]).
3. Remove the second list item..
5. Sort the list.
6. Reverse the list.

## Quiz
1. What does my_list.pop() return?
2. Who does number 2 work for? (That's a joke).
3. How do you get the length of a list?
4. If you have a string that is a sentence, how can you get back each word in the sentence as a list of strings?
5. Does the value `true` mean the same thing as the value `True`?

## Explain
1. Explain to someone when you would use a Python list and what it is.

## Joke break
*What do you call an apology sent by Morse code?*

Remorse code! üòÇ 

# Dictionaries
Dictionaries are another super-common Python data structure. 

## dict
A dictionary consists of key-value pairs. The Python type you'll see is `dict`.

![Dictionary](images/dictionary.jpg){#figcaption:dictionary}

### Create a dict
Let's make an empty dict.

```python
my_empty_dict = {}
my_empty_dict
```


    {}

That's empty. 

When you see squiggly brackets, you're seeing a dictionary being made. 


```python
type(my_empty_dict)
```


    dict

Let's make a dictionary with some key-value pairs. 

```python
my_dict = {
    "truck": 18, 
    "car": 4,
    "bike": 2, 
    "unicycle": 1
}
```

Each key is a mode of transportation and each value is the number of wheels.

To relate a Python dict to a physical dictionary, the word you're looking up is like the key. The definition is equivalent to the value.

```python
my_dict.get('bike')
```


### Get a dictionary value by its key

Use `get()` to GET a dictionary value when you know the key.

The `get()` method follows the same syntax as other methods. Because it's a dictionary method, you'll use parentheses with the name of the key. 

Because the key is a string, it goes in quotes.
You can use either single or double quotes ‚Äî doesn't matter so long as the beginning quote type matches the ending quote type. üòÄ

```python
my_dict.get('bike')
```


    2

`get` returns the value.

A second way that you will see people access a dictionary item is through square bracket notation. Like accessing a list value, you type the dictionary name, followed by the key in square brackets `[]`. 

If the key is a string, make sure you put it in quotes.

```python
my_dict['bike']
```


    2

There's a caveat for accessing the value like this, though. If the key doesn't exists, you'll get an error.

```python
my_dict['boat']
```

    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-281-3524a7b4a5c5> in <module>
    ----> 1 my_dict['boat']
    

    KeyError: 'boat'


So, although a dictionary value is often accessed with square brackets `[]`, you should use the `get()` method, generally.

### Add an item to a dictionary
Add a new key-value pair to your dictionary by putting the new key in square brackets and using the `=` assignment operator to assign it a value.

```python
my_dict['trike'] = 3
my_dict
```


    {'truck': 18, 'car': 4, 'bike': 2, 'unicycle': 1, 'trike': 3}

Note that a dictionary's keys must be unique. You couldn't add another `'truck'` key to `my_dict`.

### Change a dictionary value
Similarly to adding a value to a dictionary, you reassign a value to a key-value pair by referencing the existing key. For example, let's change the value associated with `'bike'` in `my_dict`.

```python
my_dict['bike'] = 3
my_dict.get('bike')
```


    3

Done.

### Return the dictionary keys 
Use the `keys()` method to return all the keys.

```python
my_dict.keys()
```


    dict_keys(['truck', 'car', 'bike', 'unicycle', 'trike'])

### Return key-value pairs 

You can get all the key-value pairs back at the same time with the `items()` method.


```python
my_dict.items()
```


    dict_items([('truck', 18), ('car', 4), ('bike', 3), ('unicycle', 1), ('trike', 3)])

### Return values 
You can return all the values with the `values()` method.

```python
my_dict.values()
```


    dict_values([18, 4, 3, 1, 3])

### Combine two dictionaries 

Concatenating dictionaries takes a bit more work than concatenating lists or strings. You can't use the addition `+` sign. Instead, use the `.update()` method. 


```python
my_second_dict = dict(a=3, b = 5)
```


```python
# my_combined_dict = my_dict + my_second_dict
```

    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-285-c5b7b757d180> in <module>
          1 my_second_dict = dict(a=3, b = 5)
    ----> 2 my_combined_dict = my_dict + my_second_dict
    

    TypeError: unsupported operand type(s) for +: 'dict' and 'dict'


You gotta .update() to combine your dicts!

```python
my_new_dict = my_dict.update(my_second_dict) 
my_new_dict
```


    {'truck': 18, 'car': 4, 'bike': 3, 'unicycle': 1, 'trike': 3, 'a': 3, 'b': 5}



Now you have a merged dictionary. Notice that the second dictionary gets passed to `update()`. Its key-value pairs will get appended to the existing key-value pairs in the dictionary.

Here's a little ditty to help your remember:

If combining dictionaries is your goal,

then UPDATE them to make them whole. 

### Remove a dictionary item 

Like with a list, use `pop()` to remove an a key-value pair. You must pass the key you want to remove to `pop()`. 

The value of the item removed gets returned, so you can assign it to a variable.


```python
popped_value  = my_dict.pop('trike')
print(my_dict)
print(popped_value)
```

    {'truck': 18, 'car': 4, 'bike': 3, 'unicycle': 1, 'a': 3, 'b': 5}
    3


### Check whether a dictionary key exists 

Use the `in()` method to see if a dictionary key is in a dict.

`in()` returns `True` if the key exists, and otherwise returns `False`.


```python
'unicycle' in my_dict
```


    True

### Get the number of items in a dict

You can use `len()` to get the number of key-value pairs, just as you used it with lists.

```python
len(my_dict)
```


    6

### Dictionaries are insertion ordered
Since Python 3.6 dictionaries in Python are guaranteed to keep their key-value pairs in the same order. The items are accessible in the same order in which they were inserted into the dictionary. 

## Summary
Although dictionaries share some similarities with lists, they are useful in different situations. For example, if you need labels to keep track of your data, use a dict. 

That's all you need to know about dictionaries for now. I'll come back to more advanced dictionary features later in the book.

### Recap
- `my_dict = {}` ‚Äî create a dict. 
- `my_dict[my_key] = my_value` ‚Äî add a key-value pair.
- `my_dict[my_existing_key] = my_value` ‚Äî change a value associated with a key. 
- `update(my_dict)` ‚Äî concatenate two dicts.
- `pop(my_key)` ‚Äî remove the key-value pair of the specified key.

#### Methods to return items or information

 The following methods return useful things about dicts.
 
- `in(my_key)` ‚Äî return true if key exists.
- `get(my_key)` ‚Äî return the value of the specified key.
- `values()` ‚Äî return all values.
- `keys()` ‚Äî return all keys.
- `items()` ‚Äî return all key-value pairs.

- `len(my_dict)` ‚Äî return the number of items in the dict. As always with `len()`, Note that the object gets passed to it.

## Practice
1. Make two dictionaries and fill them with some items.
2. Concatenate the dictionaries.
3. Remove the second item from the new dict.
4. Add a new item to the dict.
5. Return all the items in the dict.

## Quiz
1. What does it mean that dictionaries are insertion ordered?
2. Do keys come before values when making a dictionary?
3. How do you return a value associated with a dict key?

## Explain
1. What's a Python dictionary and when would you use one?

## Joke Break

That's a lot of content. You could definitely use a joke break. Well, lucky for you, I've got one ready to go.

*Why should you never take advice from electrons?*

Because they are always negative!

# If Statements 
Programing languages contain *control flow* statements that allow them to execute different lines of code in different situations. This logic capability gives computer programs much of their power. 

*If statements* are also called conditional statements, because different code runs in different conditions. Here's the basic syntax for an *if* statement:

```python
if True:
    # then do stuff in this block
```
 
The value on the line with the *if* statement is evaluated first. If it evaluates to `True`, then the indented block of code immediately following the statement is executed. 

Note that the *if* statement concludes with a colon `:`. Don't forget the colon or your code won't run.

Here's a more realistic example of an `if` statement.

```python
my_number = 3
my_important_variable = 0

if my_number > 2:
    my_important_variable +=1

my_important_variable
```


    1

Indentation matters for *if* statements. Indent all the lines in the code block under the *if* statement four spaces ‚Äî that's the official [Python Style Guide recommendation](https://www.python.org/dev/peps/pep-0008/#id17). The Colab default indentation is two spaces for code blocks. That's fine, too. Just be consistent with either two or four spaces of indentation.

If the condition evaluates to `False`, then the indented block of code under it doesn't run. It gets skipped. Then the next line of code that matches the indentation of the *if* statement is executed.

```python
my_number = 1
my_important_variable = 0

if my_number > 2:
    # then do stuff in this block
    my_important_variable +=1

my_important_variable
```

    0

The *if* statement condition evaluates to `False` so `my_important_variable` never gets incremented.

The line `my_important_variable` is back at the same level of indentation as where the *if* statement started, so it will always run, regardless of whether the *if* statement evaluated to `True` or `False`.

You can use `and`, `or`, and `not` in your *if* statements.

```python
x = 1
y = 2

if x == 1 and y == 2:
    print("Both parts are True")
```

    Both parts are True

## if...else
Sometimes you'll want to do one thing if a condition is `True` and something else if it's `False`

```python
my_age = 16

if my_age < 20:
    print("funny")
else:
    print("silly")
    
```

    funny

Adding an *else* block after an *if* block allows you to specify other code you'd like to run when the condition evaluates to `False`. 

Note that *else* requires a colon immediately following it. The code to run in the *else* condition must be indented, too.

## if...elif...else
Sometimes you want to check multiple conditions and do different things in different situations. In that case, follow the pattern *if...elif...else*.

```python
home = "DC"

if home == "AZ":
    print("Arizona")
elif home == "OH":
    print("Ohio")
else:
    print("Home is not Ohio or Arizona")
```

    Home is not Ohio or Arizona

The *elif* statement requires a colon at the end of its line, too. Then, an indented code block must follow the *elif* line. 

You can have multiple *elif* conditions, like this:

```python
home = "DC"

if home == "AZ":
    print("Arizona")
elif home == "OH":
    print("Ohio")
elif home == "MD":
    print("Maryland")
else:
    print("Home is not Arizona, Maryland, or Ohio")
```

    Home is not Arizona, Maryland, or Ohio

## Nested If Statements
If you nest an *if* statement, the nested statement will only get evaluated if the program control reaches that branch of the program.

```python
state = "AZ"
city = "Tucson"

if state == "AZ":
    print("Arizona")
    if city == "Phoenix":
        print("Phoenix")
    elif city == "Tucson":
        print("Tucson")
    else:
        print("City isn't Tucson or Phoenix")
elif home == "MD":
    print("Maryland")
    if city == "Tucson":
        print("Nope, Tucson isn't in Maryland")
else:
    print("Home is not Arizona or Maryland")
print("The end")
```

    Arizona
    Tucson
    The end

As soon as an *if* statement evaluates to `True`, it runs the block of code under it and then skips to the end of the *if* statement - skipping over any *elif* and *else* statements. Even though `city == "Tucson"` is `True`, the *elif* `home == "MD"` branch and the *if* statement in its code block never get evaluated. 

Note that the `print("The end")` statement always runs because it is at the same indentation level as the first *if* statement.

## Summary
*If* statements are fundamental to programming. They allow you to implement logic.

With *if* statements remember that this is the format:

```python
if True:
  # do indented code
```

If you have multiple conditions to check for, use `elif` and `else`.

```python
if True:
  # do indented code
elif True:
  # do indented code
else: 
  # both conditions were False
  # do something else
```

## Practice
1. Make a list and check if the first item in a list is equal to "A"
2. Check if the last time in a list is not equal to "Z", without knowing how long the list is.
3. Make a dict and return a value from it.
4. Make an if statement to check whether a key exists in a dictionary. If it exists print "yes". Otherwise, print "no".

## Quiz
1. How can you get the last value in a list?
2. When would you use an *if* statement?
3. When would you use an *else* clause?
4. When would you use and *elif* clause?
5. What symbol does every control flow evaluation statement end with?

## Explain
1. Explain to someone what an *if* statement does and when you'd use it.

## Joke Break
There's a bit more going on in these recent chapters. Definitely need a joke. 

*Why can't your nose be 12 inches long*

Because then it'd be a foot! üòÇ

# For Loops
*For loops* are another control flow construct. They are used to iterate over something. 

*For* loops are often used with lists. Here's an example:

```python
scooter_list = ['lime', 'bird', 'jump', 'lemon']

for scooter in scooter_list:
    print(scooter)
```

    lime
    bird
    jump
    Lemon
    
## Iterables
An *iterable* is something that a for loop can iterate over. Strings, lists, and dictionaries are all iterables. Iterable is one of those words that pops up in Python (and gets confused with iterators - can you imagine why?). I'll spare your iterators in this book. üòâ 

Just remember that an iterable is something you can loop over. You can just think of a list for now.

## For Loop Patterns
*For* loops follow this pattern:

```python
for my_temporary_variable in my_object:
    # my code to run once for each item in my_object
```

A *for* loop statement is built with the following parts, in order from left to right.

- starts with *for*
- any_temporary_variable_name you like 
- *in*
- the thing being looped over
- a colon `:`

The *for* statement is followed by an indented code block that starts on the next line.

The *for* loop will run once for each item in the iterable. 

On each loop, the value of the temporary variable changes to the next item in the iterable. 

The temporary variable can be used in the indented block that follows the *for* statement.

*For* loops are kind of like *if* statements set to repeat.

Here's a little trickier *for* loop:

```python
prices = [100, 200, 300]
counter = 0
for price in prices:
    print(price)
    price += 10
    prices[counter] = price
    counter += 1
    
prices
```

    100
    200
    300
    [110, 210, 310]

What's going on here? Let's break this down step by step. It's often helpful to keep a hand written table of each variable and its current value on scratch paper. Update it as you step through the code.

There are better ways to accomplish this, but our focus is on learning how to read *for* loops.

The list `prices` and integer `counter` are declared outside the for loop. That's fine, variables declared in the main program ‚Äî not in any function ‚Äî are accessible throughout the code. They have *global scope*.

The temporary variable `price` has the value 100 at the start of the indented code block. Then 200 the second time. Then 300 the third time. 

Each time the statement `print(price)` prints the price.  

The first time through `price` starts at 100, then it gets 10 added to it, so its value becomes 110.

`my_list[counter]` is set the value of `price`, which is 110. So `my_list[0]` becomes 110.

Then `counter` gets incremented by 1.

At the end of the first loop the variables contain these values:

`price` is 110

`counter` is 1

`prices` contains the values 110, 200, and 300.

The loop starts for the second time and `price` becomes the value of the second item in `prices`. So `price` is now 200.

200 + 10 = 210 so `price` becomes 210.

`prices[1]` = 210. So now the list `prices` contains the ints 110, 210, and 300. 

`counter` gets incremented to 2.

Third loop:

`price` becomes 300.

`price` gets 10 added to it and becomes 310.

`prices[2]` gets 310

`counter` gets 1 added to it. Its value becomes 3.

No more items in the `prices` list. Control passes back to the outdented level of code that follows the *for* loop. So `prices` outputs `[110, 210, 310]`.

This was a small example, but extrapolate it to a list of thousands of values. It's much nicer to use a list and for loop than to manually update each item one at a time. üòÅ

## For Loops With If Statements

![Siamese Cat](images/siamese.jpg){#figcaption:siamese}

Let's nest an if statement in a for loop. 

```
python
siamese_counter = 0
cats = ["sphinx", "siamese", "sphinx", "tabby", "siamese"]

for cat in cats:
    if cat == "siamese":
        siamese_counter += 1
        
print(f"Total siamese cats: {siamese_counter}")

```

    Total siamese cats: 2

The *if* statement code gets checked each time the code runs. But the indented code block under it only runs when it evaluates to `True`. It only evaluates to True when cat is set to `"siamese"`. So `siamese_counter` only gets incremented twice. Make sense?

## Summary
For loops are a very useful feature of any programming language. Python *for* statements follow this format:

```python
for temp_var in my_iterable:
    # do indented code once for each item 
```

## Practice
1. Make a list of numbers. Use a *for* loop to iterate over the items in it. Print each number.
2. Adjust your code so that you keep track of how many odd numbers are in your list.
3. Adjust your code so you only print even numbers. 
4. Make an *if* statement that runs a *for* loop only when `False`.

## Explain

1. Explain to someone what a *for* loop does and when you'd use one.

## Joke Break
*Want to hear a joke about construction?*

I'm still working on it.

# The Myth of the Born Coder

![Pegasus](images/pegasus.jpg){#figcaption:pegasus}

No one is born knowing how to write a *for* loop. 

Don't get discouraged if you see someone coding on YouTube and they make it look easy while you get lots of errors. That person made lots of errors for a long time, too. And they probably edited their video.üòâ

True, some things come easier to some folks. However, everyone had to put in the time. Everyone gets frustrated. Look at it this way: you learn something in every struggle. 

I quit learning how to code multiple times because I found it too hard. I was used to things coming easy, and coding didn't. I figured I just wasn't cut out for it.

Then I changed my mindset to a [growth mindset](https://www.mindsetworks.com/science/). I embraced failure as part of learning. I forgot things, made mistakes, and sometimes got frustrated. But I realized that's okay. It's not always going to be easy. And you know what? The more I did it, the easier it got.

Now I teach other people how to code. If I can do it, so can you. No matter your background, you belong here. If you have access to a computer and can persist, you can learn to code. 

This book is designed to speed the learning process as much as possible, but learning Python and coding concepts takes persistence.

It's just persistence. 

End of pep talk. Onward! üöÄ

# Functions
A *function* is a reusable section of code that runs when you call it. Functions can either be made by you or you can use functions that someone else has already written. Functions are like verbs ‚Äî they do things.

## User Defined Functions
A user-defined function is one that you create. Declare a function like this:

```python
def my_function():
    # do something
    return
```

Things to remember when creating a function:

- start with `def`
- then type the function name that you make up. Name your function so it describes what the function does. üòÉ
- add parentheses immediately after the name. Leave no spaces between the name and the open paren `(`.
- indent the code block that will run when the function is called.
- the keyword `return` denotes the end of the function. You can return a value or not return anything.

Control then returns back to wherever the function was called from.

Declare a function first, higher up in the code, before you call it.

Declaring a function doesn't make anything happen. You have to call it for it to run. Call the function so that it executes like this:

```python
my_function()
```

Remember, you call a function with the function name, followed by parentheses.

### Return values
As mentioned above, a function can return a value. Just put a value, an expression, or a variable on the same line after the word `return`.

Here's an example of a function that returns the the value of the variable `z`. When control passes back to the line where it was called the return value gets assigned to the variable my_variable.

```python
def my_function_that_adds():
    z = 21
    print(z + 10)
    return z

my_variable = my_function_that_adds()
print(my_variable)
```

    31
    21


Here's the step-by-step:

- `my_function_that_adds` is defined. 
- `my_function_that_adds()` is called. 
- The variable `z` gets 21.
- `print(z + 10)` causes 31 to be printed to the screen.
- Then the return value for `z`, which is 21, gets assigned to `my_variable`.
- Finally, `print(my_variable)` causes the value of `my_variable` to be printed.

### Parameters and arguments
When a function is defined you can give it *parameters* ‚Äî variables you pass to it that get their own name and can be used within the function only. 

In the function below there are two parameters, *first_number* and *second_number*.

```python
def my_function_that_adds(first_number, second_number):
    total = first_number + second_number
    return total
```

When you call this function, you have to pass it two values. You can pass it literal values, or variables that hold values. When you are passing a function values, they are called arguments, instead of parameters. You'll hear folks confuse this splitting-hairs distinction.

Parameters when defined,
Arguments when called.

Remember **PDAC**

**P**arameters at \
**D**efinition \

**A**rguments at \
**C**all \

Below we call `my_function_that_adds()` and pass it the integer value 10 and the variable `second_var`, which is set to the value 5. 

```
second = 5
my_return_value = my_function_that_adds(10, second_var)
my_return_value
```

    15


Within the function, `first_number` gets the value of the first number passed to the function, so in this case that's 10. `second_number` gets the second value passed to the function, so in this case that's 5. 

The code in the indented code block adds those numbers together and stores the result in the variable `total`. 

Then the value of `total` get returned to where the function was called from and assigned to `my_return_value`. 

The value in `my_return_value` then gets printed to the screen.

#### Default parameter values
A function definition can specify *default parameter values*. Those values will be used if no arguments are passed to the function. Here's an example with two default parameters.

```python
def second_addition_function(first_number=20, second_number=30):
    total = first_number + second_number
    return total

my_return_value = second_addition_function()
my_return_value
```

    50

The defaults of 20 and 30 can be overridden by passing arguments to the function, like in the example below.

```python
def my_function_that_adds(first_number=20, second_number=30):
    total = first_number + second_number
    return total

my_return_value = my_function_that_adds(-10, -25)
my_return_value
```


    -35

`first_number` gets -10 and `second_number` gets -25 when the function is called.

#### Keyword arguments
You've seen that when you can pass arguments to a function from specific positions. Alternatively, you can specify arguments by including the name of the parameter. These are called *keyword arguments*. 

Keyword arguments are useful when you know the names of the parameters, but don't know what position the arguments need to be in. Below is an example where the function is called with keyword arguments.

```python
def subtraction_func(first_number=20, second_number=30):
    total = first_number - second_number
    return total

my_return_value = subtraction_func(second_number=10, first_number=25)
my_return_value
```

    15

See how you specified the name of the parameters when you called `subtraction_func()`?

## Built-in Functions
You've used many built-in functions in this book. You don't have to install or define a built-in function. Other nice folks wrote them. You can just call them. üëç

For example you can call `upper()` on a string like this:

```python
a_string = "why not this string?"
a_string.upper()
```
    
    "WHY NOT THIS STRING?"

This is technically an example of a method - a method is just a function of a class. I'm putting off discussing classes for now. If you see the term *method*, just think *function*. I'll use the two terms interchangeably when discussing what are technically methods.

If you want to know what a specific function signature looks like, you can use the built-in help function. Just pass the name of the function you'd like help with like this: `help(function_name)`. 


```python
help(str.upper)
```

    Help on method_descriptor:
    
    upper(self, /)
        Return a copy of the string converted to uppercase.
    
You can also use functions that have been imported from other modules. I'll discuss imports in a bit. For now, just know that once a function is imported you can use it just like any other function.

## Method Chains
You can chain multiple function calls together. Let's look at an example. You'll declare a string, make it all lowercase, and then replace some parts of it.  

```python
my_string = "Beep, BAP, beep, beepidy-beep!"
my_cheap_string = my_string.lower()
my_cheap_string.replace('beep', 'cheap')
```


    'cheap, BAP, cheap, cheapidy-cheap!'

You can combine these two method calls on single line by changing the code to the following:

```python
my_cheap_string.lower().replace('beep', 'cheap')
```


    'cheap, BAP, cheap, cheapidy-cheap!'

![Chain](images/singlechain.jpg){#figcaption:chain}

Function chains are executed from left to right. First the `.lower()` function is executed and then the `.replace()` function is executed.

Using method chains can make your code more concise. But a long method chain can be difficult to read, so don't go hog wild. üê∑

## Summary

Functions are great for keeping your code DRY. DRY stands for Don't Repeat Yourself. I didn't make that up, It's one of the few mnemonics common to programming. üòâ

Define a function like this:

```python
def my_fun():
    return 
```

Return a value like this:

```python
def my_funny():
    return "funny"
```

Add a parameter like this:

```python
def my_func(number_to_square):
    squared = number_to_square
    return squared
```

Add a default argument like this:

```python
def my_func(number_to_square=10):
    squared = number_to_square
    return squared
```

Call a function with no parameters like this:

```python
my_fun()
```

Call a function and assign a return value to a variable like this:

```python
my_var = my_funny()
```

Call a function like this, with a positional argument:

```python
squared_number = my_func(5)
```

Or with a keyword argument, like this:

```python
squared_number = my_func(number_to_square=5)
```

Chain method calls to save space like this:

```python
my_string.upper().rstrip()
```

Get help with a function like this.

```python
help(list.pop)
```

Now you've seen the basics of functions. Let's get some practice with them.

## Practice
1. Make a list. Chain two list method calls together.
2. Make a dictionary with strings for keys and values.
3. Make a function the takes a dictionary as a parameter. It should return the same dictionary with all the keys reversed. 
4. Call the function you made and pass it the dictionary you made as a positional argument.
5. Call the function you made and pass it the dictionary you made as a keyword argument.

## Quiz
1. What's the difference between a keyword argument and a positional argument?

## Explain
What's a function and when do you need to make one?

## Joke Break
*How many tickles does it take to tickle an octopus?*

Ten-tickles. Bet you thought eight!

# File Input and Output
You can input many types of data in a Jupyter notebook from external files. 

## Accessing Files in Colab
There are a number of ways to input files into Colab. I think the most straightforward is by mounting your Google Drive into your Colab environment. Google Drive is a cloud-based repository for your files. Your files and folders in Drive live on Google's servers and you can access them through a web browser. [Here's more info](https://support.google.com/drive/answer/2424384?co=GENIE.Platform%3DDesktop&hl=en) on working with Google Drive.

When you mount your Google Drive then you can access all the files you store there in Colab. You mount your files like this:

```python
from google.colab import drive
drive.mount('/content/drive')
```

Run that cell in your Colab notebook. The cell output will something like this:

    Go to this URL in a browser: https://accounts.google.com/o/oauth2/auth?client_id=94731898_long_url_from_google_here
    Enter your authorization code:
    
- Click on the link in the output cell. You will be taken to a page that will ask you to authorize Colab to access your Drive. 
- Allow access. You will be redirected to a page with a code. 
- Copy the code. 
- Click on your Colab browser tab. 
- Paste the code into the box in the output cell and press enter.
- After a few seconds you should see the cell output state:
      
      Mounted at /content/drive

Cool! Now enter the following two lines of code so we have a file to read in Drive. We'll talk about them in a bit.

```python
with open('/content/drive/My Drive/my_file.txt', 'a+') as f:
    f.write('This text is in a file in Google Drive!')
```

## Read Data
Read in data from a text file using a *with* statement like this:
 
```python
with open("/content/drive/My Drive/my_file.txt") as my_file:
    data = my_file.read()
    print(data)
```

Note that you actually need to have a file named *my_file.txt* in the directory where your notebook is running to read in this file. 

Then `my_file.txt` opens in read-only mode, which you could denote by an `r`, by default. 

`my_file` is a handle you can use to refer to the file anywhere in your indented code block. 

Once again, you need a colon at the end of the *with* statement.

Once again, you indent our code. All of the code that you want to do something with while your file is open goes in the indented code block.

In the code block you set the variable `data` to the result of calling the `read()` method on `my_file`. So `data` is a string variable that contains the content from the file.

The file closes automatically when control leaves the *with* block.

## Write Data
You can't write data to a file that is open in read-only mode. That's a safety feature.üîí

You can create a file and write to it when it's in `a+` mode, as you saw above.

```python
with open("/content/drive/My Drive/my_file.txt", "a+") as my_file:
    my_file.write("Writing/wrote this text to file.")
```

In the context block, you can use the `write()` method. You pass it the text you want to put in the file. 

You can read and write to a file when you open it in `a+` mode. 

Python offers a variety of ways to open files and several modes for reading and writing to them. It's a best practice to use a *with* statement so that you don't need to explicitly close the file. You wouldn't want to forget to close it. 

## Summary
Read from a file by using a `with` context block. 

```python
with open("/content/drive/My Drive/my_file.txt") as f:
    my_data = f.read()
    print(my_data)
```

Read and write to a file by specifying `a+`. 

```python
with open("/content/drive/My Drive/my_file.txt", "a+") as f:
    f.write("This text will get appended to existing text in the file.")
```

`a+` is for reading PLUS writing.

### Remember

`r` is for reading. It's the default
`a+` is for reading and writing. It creates a file if it doesn't exist. It appends anything you write to the end of a file if it exists.

#### Mnemonic

With an `a+` it means you can do anything. üòÅ

## Practice
1. Write text to a new file using Python code.
2. Open the file using Python code and read the contents.
3. Change the contents of the file using Python code.
4. Make a list and iterate through it with a *for* loop that prints the values in the list.
5. Take five deep breaths. üòÅ

## Explain
Explain to someone why you should you use a *with* statement when opening a file?

# Strings Part 2
Let's look at how to do more things with strings!

### Using both single and double quotes
To print a single quote in a string, use double quotes to enclose the string.

```python
print(" ' ")
```

To print a double quote in a string, use single quotes to enclose the string.

```python
print(' " ')
```

Make sense?

### Print strings on multiple lines

You can make text print on the following line by inserting the newline character `\n` like this.

```python
print("we \n can \n do\n it!")
```

    we 
     can 
     do
     it!


### Print multiple values on the same line

Use a plus sign `+` between two variables in a `print()` statement to print them on the same line. They will print with no spaces between them.

```python
'a' + 'b'
```

    Ab

If you want a space, separate the strings with a comma. 

```python
'a', 'b'
```

    a b

Remember `+` squeezes together, and `,` separates.

### Escape strings with a backslash \\
That's a backslash. It escapes the next character in a string. Use it when you need to print a symbol that means something special in Python. 

For example, if you want to print an actual backslash to your screen, you need to put an extra backslash immediately in front of it. Otherwise, the Python interpreter thinks you are using the backslash to signify a special character and throws a SyntaxError. 

```python

print("\\")
```

     \

Backslash means *escape*.

### String are iterables
A string is divisible into the individual characters that make it up. You can loop over a string with a for loop, slice it, or get its length with `len()`. 

Here's a for loop example.

```python
my_string = "honey"
for letter in my_string:
    print(letter)
```
     
    h
    o
    n
    e
    y

### String slicing
String slicing works like list slicing. Each character occupies an ordered position. For example, return the 4th character in `my_string` like this:

```python
my_string = my_string[3]
my_string
```

    'e'

### Get the length of a string with `len()`

```python
len(my_string)
```

    5

Notice that as always with the `len()` function, the syntax is `len(your_string)`. 

### f-strings 
Use *f-strings* to insert a variable's value into a string. There are several other ways to insert a variable into a string. You might see other methods elsewhere because f-strings were introduced fairly recently, as part of Python 3.6. I find f-strings to be the most concise and easiest to learn. 

```python
transportation = "a bike"
my_string = f"My vehicle is {transportation}."
my_string
```

    'My vehicle is a bike.'

The variable in parentheses, `car` gets replaced by the value of that variable when the code is executed.

f-strings follow this format:

```python
    my_var = 10
    f"My text {my_var}. More text."
```

    'My text 10. More text.'

Using an f-string is as simple as putting an `f` immediately before the opening quotes and putting your variable name in squiggly brackets `{}`.

## Summary
You learned how to do more useful things with strings.

### Recap
When you need to print a single quote, enclose the string in double quotes. 

When you need to print a double quote, enclose the string in single quotes.

Force text to the next line with a newline `\n`.

Escape a character with a backslash `\`.

Print two values on the same line adjacent to each other with `+`.

Print two values on the same line with a space in between with `,`.

Strings are iterables. You can use for loops, `len()`, and slicing with strings ‚Äî much like you can with lists.

Insert a variable's value inside a string literal with f-strings. Start the string with an `f` at the beginning and put the variable in squiggly brackets `{}`. Like this: `f"my text {my_var}."` 

## Practice
1. Make a string with a newline character somewhere in it.
2. Reverse it using string slicing.
3. Print a variable's value in a string by using an f-string.
4. Write a string to a file.
5. Make a dictionary.

## Joke Break
*Why do bears have hairy coats?*

Fur protection. üêª

# Lists Part 2
Let's get back to lists, shall we? There's more than one way to make a list. You learned how to use square brackets to define a list earlier like this:

```python
my_list = [1, 2, 3]
```

## List Constructor
Alternatively, can make a blank list by calling the list constructor function like this:

```python
my_list = list()
```

The list constructor will come in handy with ranges, our next topic.

## Range
Let's look at the built-in `range()` callable. It behaves like a function that returns a sequence of numbers. 

```python
for number in range(4):
    print(number)
```

    0
    1
    2
    3

If range is passed a single number, it will start at zero and return each number up to that number. The number passed is excluded from the numbers returned.

If range is passed two numbers, the first is the starting number and the second is the ending number. The ending number is still exclusive. 

```python
for the_number in range(3,5):
    print(the_number)
```

    3
    4

If range is passed three numbers, the first is the starting number. The second is the stopping number (exclusive). The third number is the step; the interval to count by. 

```python
for numbers in range(2,11,3):
    print(numbers)
```

    2
    5
    8

![Range](images/field.jpg){#figcaption:range}

Here's how you can figure out what range will return:

- The first number is 2. 
- Then count by 3 and get the number 5.
- Then count by 3 and get the number 8.
- Then count by 3 and get the number 11, but 11 is higher than the maximum number in the range. Remember the range upper boundary is exclusive. In this case 10 is the highest possible value. Consequently, 11 doesn't get returned.

Range is an iterable, so you can use it directly in for loops.

To actually make a list from `range()`, you pass the range object to the list constructor like this:

```python
list(range(4))
```

    [1, 2, 3]

Here's how you can use `range` with `len` and our `scooter_list` to get the list index for each item.

```python
scooter_list = ['lime', 'bird', 'jump', 'lemon']
for scooter_number in range(len(scooter_list)):
    print(scooter_number)
```

    0
    1
    2
    3

`len()` returns  the length of the `scooter_list`, which is 4. So 4 becomes the argument to `range()`. `range(4)` returns the sequence of numbers from 0 through 3, one at a time. Cool? üòÄ

## List Comprehensions
Let's use a *list comprehension* to square all the numbers in a list. The result will be stored in a new list.

```python
my_numbers_list = [3, 5, 9, 2]
my_squared_list = [number ** 2 for number in my_numbers_list]
my_squared_list
```

    [9, 25, 81, 4]
    
List compressions are a very Pythonic way to create lists. *Pythonic* means that Python coders dig them. List comprehensions often make for loops unnecessary. They are concise and generally clear, but take some getting used to. 
    
List comprehensions are built with the following pieces, from left to right.

- a variable that will become the list
- an `=` sign
- an open square bracket `[`
- the thing that will get assigned to the new list
- the keyword `for`
- a temporary variable that will represent the list item
- the keyword  `in`
- the iterable ‚Äî the thing being iterated over
- a closing square bracket `]`

As you saw earlier, a string is an iterable ‚Äî it can be iterated over by a for loop or a list comprehension. You can use a list comprehension to make a list of individual string characters from a larger string. Here's how:

```python
my_letters = [x for x in "mystring"]
my_letters
```

    ['m', 'y', 's', 't', 'r', 'i', 'n', 'g']

Notice that you're using `mystring` as a string literal, not a variable.

The same result could be achieved with a *for* loop like this:

```python

my_letters = []
for letter in "mystring":
      my_letters.append(letter)
my_letters
    
```

    ['m', 'y', 's', 't', 'r', 'i', 'n', 'g']    

The list comprehension is more concise.

You can add a conditional statement as part of a list comprehension by appending `if` to the end of the list comprehension. For example:

```python
my_list = [x for x in scooter_list if x[0] == "l"]
my_list
```

    ['lime', 'lemon']

Now only the scooters that start with letter `l` are returned.

Also, you can alter the values to be inserted into the list like this:

```python
my_list = [x.upper() for x in scooter_list if x[0] == "l"]
my_list
```

    ['LIME', 'LEMON']

When trying to make sense of a list comprehension, first look at what is being iterated over. Then read to the left to see what the temporary variable is named. Then go further to the left to see what's getting inserted into the list. Then check whether an if statement exists to filter what gets included in the list.

I suggest you don't nest multiple list comprehensions. Same goes for multiple *if* statements within list comprehensions. Both can be confusing to readers of your code. I'll trade a little verbosity for the sake of clarity any day. üòÄ

List comprehensions are powerful. Ace them and you're well on your way to Pythonista status. üêç

## Nested Lists
Lists can be nested inside each other. Let's create three lists. 

```python
a = [2, 3, 4]
b = [5, 6, 7]
c = [8, 9, 10]
```

Then let's put the lists inside another list and print them.

```python
my_list = [a, b, c]
print(my_list)
```

    [[2, 3, 4], [5, 6, 7], [8, 9, 10]]

`my_list` is a list of that contains three other lists.

### Accessing a nested list
Let's access the fist list.

```python
my_list[0]
```

    [2, 3, 4]

```python
my_list[1]
```

    [5, 6, 7]

### Accessing a nested list item 
Now let's access a single item in an inner list. Let's access the third item in the second list.

```python
my_list[1][2]
```

    7

Notice how the list at position [1] gets referenced first in square brackets. Then the third element in that list gets referenced in square brackets immediately following.

Let's loop over the list of lists, printing each list.

```python
for x in my_list:
    print(x)
```

    [2, 3, 4]
    [5, 6, 7]
    [8, 9, 10]

Let's print each individual item in the inner lists. Accessing the inner items requires nested for loops.

```python
for sub_list in my_list:
    for inner_item in sub_list:
        print(inner_item)
```

    2
    3
    4
    5
    6
    7
    8
    9
    10

For the first list, the inner loop runs three times, once for each inner list item. Then it runs three more times for the second list. Finally, it runs three more times, once for each item in the third list.

Nested lists are powerful, but can be confusing. Make sure you work with them to get comfortable.

## Enumerate 
When you need the index number as you iterate over a list, use the built-in `enumerate()` callable. 

```python
    enumerate(['a','b','c'])
``` 

	  <enumerate at 0x106310048>

`enumerate()` returns an iterable object. You can call the list constructor on it to make make a list, like you did with `range()`.  

```python
    list(enumerate(['a','b','c']))
``` 

    [(0, 'a'), (1, 'b'), (2, 'c')]

Enumerate creates a numeric value to accompany each item in an iterable. Enumerate starts numbering up from zero.   

Enumerate acts like a function, but is technically it's own special type of class. You can think of it as a function.

Here's how enumerate works in a *for* loop:

```python
dog_list = ['corgi', 'beagle', 'lab']
for the_index, the_dog in enumerate(dog_list):
    print(the_index, the_dog)
```

    0 corgi
    1 beagle
    2 lab

A *for* loop statement with `enumerate()` has the following parts ‚Äî from left to right:

- the keyword `for`
- a first temporary variable for the index
- a comma `,` 
- the usual temporary variable to hold the value of the item being iterated over
- the keyword `in`
- `enumerate(my_iterable)`
- a colon `:`

There are often multiple ways to accomplish the same thing in Python. You could have used `enumerate()` to get the indices of the scooters that you found earlier. Here's how:

```python
for scooter_number, scooter in enumerate(scooter_list):
    print(scooter_number)
```

    0
    1
    2
    3

Let's look at how you can get information from a dictionary into a list.

## Make a List with the List Constructor from dict Keys or dict Values

You can call the `keys()` method on a dictionary and pas the result to  a list like this:

```python
my_dict = {
    "truck": 18, 
    "car": 4,
    "bike": 2, 
    "unicycle": 1
}

trans_list_keys = list(my_dict.keys())
trans_list_keys
```

    ['truck', 'car', 'bike', 'unicycle']

Similarly, you can make a list from dict values.

```python
trans_list_vals = list(my_dict.values())
trans_list_vals
```

    [18, 4, 2, 1]

Alternatively, you could use a list comprehension to create the same list.

```python
trans_list_vals = [val for val in my_dict.values()]
trans_list_vals
```

    [18, 4, 2, 1]

## Summary
I covered a number of more advanced list topics in this chapter. If you think this content would be easier to remember if broken into multiple chapters, please let me know on [Twitter](https://twitter.com/discdiver).

### Recap

- List constructor ‚Äî make a list ‚Äî `list()`

- List comprehensions ‚Äî make a list ‚Äî `x for x in y`

- Range ‚Äî return a sequence of numbers ‚Äî `range(6, 2, 3)`

- Enumerate ‚Äî return a number for each item ‚Äî `enumerate(my_list)`

- Nested lists ‚Äî  `[['x'],['y']]`

- Make a list from dict keys or dict values ‚Äî `list(dict.keys())` 

Remember, range objects or enumerate objects are iterables. You can iterate over them in a *for* loop as if they were lists. But you need to pass them to the list constructor if you want an actual list.

## Practice
1. Make a range object and loop through it.
2. Make a list comprehension
3. Make a list comprehension with an *if* statement
4. Use enumerate with a list in a *for* loop
5. Write the output of using enumerate with a list in a *for* loop to a file.

## Quiz
1. How do you read in text from a file?
2. How do make a nested list?

## Explain
Explain to someone what `range()` and `enumerate()` do.

## Joke Break
*What do you call a fake noodle?* 

An impasta. üçù

# Dictionaries Part 2
A dict can be created several ways. One is by the squiggly bracket definition {} that you've seen before. Like this:

```python
my_dict = {
    "truck": 18, 
    "car": 4,
    "bike": 2, 
    "unicycle": 1
}
```

I'm not getting extensively into code style in this book, but I recommend that you follow a style like this for long lines within any type of brackets. 

Leave the open bracket on the first line with the rest of the start of the definition. Indent the contents the same number of spaces you would in a code block. Put the closing bracket at the same indentation level as the start of the definition.

Let's look at a second way to create dictionaries.

## dict() Constructor
 Similar to the list constructor, you can use the dict constructor to create a dictionary. 

```python
my_dict = dict(truck=18, car=4, bike=2, unicycle=1)
my_dict
```

    {'truck': 18, 'car': 4, 'bike': 2, 'unicycle': 1}

Notice how the dict constructor method doesn't require the quotes around the keys, because you are passing arguments. Relatedly, you use `=` instead of `:` because you are passing keyword arguments.  

I prefer to use the dict constructor when making dictionaries by hand. There's less to type. That means less to mess up. üëç

Just remember the keys and values are being passed as keyword arguments, so no quotes around keys and no colons. 

![Constructors](images/construction.jpg){#figcaption:constructors}

## Make a Dict From a List With Enumerate
You can use the dict constructor with enumerate and a list to make a dict. Each key will be a number, starting from zero.

```python
my_list_two = ["a", "b", "c"]
more_dict = dict(enumerate(my_list_two))
more_dict
```

    {0: 'a', 1: 'b', 2: 'c'}

A third way to make a dict is with a dict comprehension.

## Dict Comprehensions
*Dict comprehensions* are similar to list comprehensions. Dict comprehensions are made by setting a variable to an expression in squiggly brackets. Dict comprehensions require iterating over two iterables of matching lengths. 

Here's an example that makes a dict using enumerate with a list:

```python
value_list = ["good", "day", "today"]
a_dict = {k: v for k, v in enumerate(value_list)}
a_dict
```

    {0: 'good', 1: 'day', 2: 'today'}
    
Dict comprehensions follow this pattern:

`{resulting_keys: resulting_values for iteration in iterables}`

Dict comprehensions are built with the following pieces, from left to right:

- a variable that will become the dict
- an `=` sign
- an open squiggly bracket `{`
- a temporary key variable that will get assigned to the final keys
- a colon `:`
- a temporary value variable that will get assigned to the values
- the keyword `for`
- a temporary key variable for the iteration (must match the other temporary key variable)
- a comma `,`
- a temporary value variable for the iteration (must match the other temporary value variable) 
- the keyword  `in`
- the iterables ‚Äî the things being iterated over
- a closing squiggly bracket `}`

### Dict comprehension conditionals
Like list comprehensions, dict comprehensions can include an *if* clause to filter the items that get included in the dict. For example:

```python
value_list = ["good", "day", "today"]
a_dict = {k: v for k, v in enumerate(value_list) if k > 1}
a_dict
```

    {2: 'today'}

When the key is greater than one, the item gets included in the dictionary.

## Use zip()
Like a zipper, `zip()` brings two things together, pairing them.

![Zip](images/zipper.png){#figcaption:zipper}

The `zip()` callable pairs the items of two data structures, such as lists. The items paired must be equal length. For example:

```python
my_list_one = [1, 2, 4]
my_list_two = ["a", "b", "c"]
zip(my_list_one, my_list_two)
```

    <zip at 0x115125608>

`zip()` returns a zip object. To actually return a dict, you need to pass the dict constructor the zip object.

```python
another_dict = dict(zip(my_list_one, my_list_two))
another_dict
```

    {1: 'a', 2: 'b', 4: 'c'}

To decode what's happening here, read from the inside of the most inner-enclosing brackets to the outside. First the two lists are zipped. Then the zip object is sent to the dict constructor with `my_list_one` as the keys and `my_list_two` as the values. The new dict is assigned to the `another_dict` variable.

You could achieve the same result with a dict comprehension that uses `zip()`.

```python
another_dict = {my_key: my_val for my_key, my_val in zip(my_list_one, my_list_two)}
another_dict
```

    {1: 'a', 2: 'b', 4: 'c'}

## Summary
`dict()` ‚Äî dictionary constructor

Dict comprehensions ‚Äî `my_dict = {k: v for k, v in zip(my_list1, my_list2)}`

`zip()` ‚Äî pair things. Visualize a zipper bringing matching teeth together.

Use `enumerate()` to make a dict if you want the keys to be set to index numbers.

Dict comprehensions can be confusing. There are a bunch of parts. By using them, you are moving from beginner to intermediate territory. If you find them rough, don't get discouraged. 

## Practice
1. Make a dictionary from a list with the dict constructor. Use `range()` to make the keys.
2. Make a dictionary from a list with a dict comprehension. Use `range()` to make the keys.
3. Return the value at key 0.
4. Change the value at key 1.
5. Square all the keys using a dict comprehension.

## Quiz
1. What are three ways to make a list?
2. What are three ways to make a dictionary?

## Explain
What does `zip()` do?

## Joke Break
*Why did the coffee file a police report?*

It got mugged. ‚òïÔ∏è

# While loops
You've seen *if* statements and *for* loops. A third type of control flow structure is the *while* loop. 

A *while* statement runs repeatedly while a condition is `True`. Here's a basic *while* loop:

```python
counter = 0
while counter < 5:
    print(counter)
    counter += 1
```

    0
    1
    2
    3
    4

A *while* loop has the following components:
- the keyword `while`   
- a boolean condition (such as `counter < 5`)
- a colon `:`
- an indented block of code to run while the condition is `True`
- a way for the condition to become `False `

The code in the indented code block runs and then the boolean condition is checked again.

If the condition never becomes `False`, your program never progresses past the indented code block. This is known as an *infinite loop*. This outcome is obviously sub-optimal. 

## break 
![Break](images/break.jpg){!fig:break}

You can exit a *while* loop at any time with a *break* statement. Here's an example:

```python
x = 2
while x < 3:
    if x == 2:
        print("Inside")
        break
    print("This won't print")
print("Outside")
```

    Inside
    Outside

Notice that `print("This won't print")` is never reached. `break` immediately passes control outside the `while` loop. `break` has no affect on *if* statements
    
FYI, you can also use a *break* statement to exit a *for* loop.

*While* loops are useful when you are waiting for user input to change the state of your program to a condition that will evaluate as `False`. Because you don't know when that input is coming, you can't just count down with a `for` loop.

One other note if you're coming from another language: there are no *case* statements in Python. So don't try to use one. üòâ

## Summary
*While* loops are often helpful with user input. 

*While* loops run each time their condition is `True`.

`break` sends control out of a *while* loop or *for* loop.

If a loop never exits, your program is stuck in an infinite loop. 

You can remember when to use *for* loops and when to use *while* loops with this rhyme.

*For* to iterate,
*While* to wait.

## Practice
1. In the case above you don't really need a *while* loop. You could just use a *for* loop. Rewrite the *while* loop as a *for* loop.
2. Make a string that consists of a sentence. Replace a value in the string with another value.
3. Make a list with a list comprehension. 
4. Get the length of a list.
5. Make a *while* loop and next an *if* statement in the indented code block.

## Explain
1. Explain to someone what a `while` loop is and when you need it.

## Joke Break
*Why don't skeletons go trick-or-treating?* 

Because they have no body to go with. üéÉ

# Classes
*Classes* are used to create objects. Classes define what objects can do.

*Instances* are like classes brought to life. They are also called *objects* or *instance objects*.

You can make as many instances of a class as you want. 

![Cookie Cutter and Cookies](images/cookie_cutter.jpg){#figcaption:cookie_cutter}

A class is like a cookie cutter. Instances are like cookies. 

Classes and instance can bundle a lot of functionality in a reusable way. You might use them when you need to preserve the state of something, such as a game.

## Define a Class
You define a class like this:

```python
class Hat:
     
     def __init__(self, color):
        self.color = color
```

You define the class with the keyword `class` followed by the name you give the class and a colon `:`. The class name should begin with an uppercase letter, by convention.

Then comes an indented code block with your class's initialization method. This function gives an instance object its default properties. It gets called automatically when you make an instance of a class. You never need to call it explicitly.  

## Instantiate an Object From a Class
Let's make two instances of the `Hat` class.

```python
cardinal = Hat('red')
blue_bird = Hat('blue')
```

When you instantiate these two objects the `__init__` method gets called automatically.

The initialization method is like other functions you've seen, with a few caveats. The function is always named `__init__` ‚Äî it has double underscores before and after the word `init`. The double underscore is called *dunder* for short and the initialization method is sometimes called *dunder init*. 

The first parameter of `__init__` is the special `self` parameter. `self` makes an instance and its attributes something that can be saved, accessed, and passed around to other instance methods. 

Python automatically passes the individual instance to `__init__` through the parameter `self` when the object is instantiated.

The `__init__` method can have other parameters. If it does, the arguments get passed to the `__init__` method at instance creation ‚Äî just like with other functions. 

In the example above, you passed the argument `red` for the `color` parameter. Then, in the code block the color property of `self` gets set to the string value `"red"`. The instance you made now has the a color property with a value of `"red"`. 

The general format for assigning properties in a class is the following: 

```python
self.my_property = my_property
```

Python keeps track of all of the properties for each instance. This is known as the *state* of the instance.
 
## Get a Property of an Instance
Return a property of the `my_hat` class like this:

```python
cardinal.color
```

    'red'

You just include the instance name, a dot, and the property name. Notice that when you access a property, you don't include any parentheses at the end. You're not calling a function. 

## Instance Methods
You can define other instance methods beyond the `__init__` method. Each method has `self` as its first parameter. Python passes the instance to the method through the `self` parameter. Then the instance method can modify the properties of the current instance. How cool is that?

Let's define a method named `change_color` that changes the color of our hat.

```python
class Hat:

    def __init__(self, color):
        self.color = color

    def change_color(self, new_color):
        self.color = new_color
        print(self.color)
```

The first parameter of the method is `self`. You don't need to pass an argument for self. Self IS THE INSTANCE when you call the method. It's kind of crazy to wrap your head around. 

Let's make an instance of the `Hat` class and name it `my_hat`.

```python
my_hat = Hat("green")
my_hat.color
```

    'green'

Now let's call the `change_color` instance method with the argument `"blue"`.

```python
my_hat.change_color("blue")
```

    blue

Our instance method has a `print(self.color)` statement, so the `color` property of the current instance prints to the screen.

The general format of an instance method call is the following:

```python
my_instance.my_method(my_arguments)
```

## Change an Object's Properties
You can directly alter a property that belongs to an object by setting a new value equal to the attribute. For example, you could skip the whole method thing and just change the color directly. 

Let's change the color of `my_hat` to `pink`.

```python
my_hat.color = "pink"
```

The format to change an instance property is as follows:

```python
my_instance.my_attribute = my_new_attribute_value
```

## Summary
Understanding classes is fundamental to understanding Python. Classes can take some practice to get used to. 

### Mnemonics
- Picture a cookie cutter for a class. 
- Picture a cookie for an instance of a class.

- Classes get Caps
- Properties don't need parentheses

- dunder `__init__`
- `self` comes first

- `self.property` = arg

- `self` is the instance

I won't dive into class inheritance in this book. I'll save that for the next installment in the Memorable Python series. üòÄ

### Recap

#### Define a class 

```python
class My_class:

    def __init__(self, my_attribute):
        self.my_attribute = my_attribute
        
    def some_instance_method(self):
        print("Hi")
```

- Remember the `class` keyword
- Start the class name with a capital letter
- No parentheses
- Colon at the end
- Indent code block

Initialization method: 
- `def __init__(self):` 
- Indent code block
- Set `self.my_property = my_property`

Instance method:
- `def my_instance_method(self):`
- Indent code block
- You have the instance to work with through `self`.

#### Create an instance 

```python
my_instance = My_class(my_attribute)
```

- Make an instance name
- `=` 
- Class name
- Put any arguments in parentheses 

#### Get an instance property

```python
my_instance.my_property
```

#### Change an instance property

```python
my_instance.my_property = my_value
```

#### Call an instance method

```python
my_instance.my_method(my_args)
```

## Practice
1. Make a class with an `__init__` method.
2. Make an instance method.
3. Instantiate an object of the class.
4. Change a property of the instance.
5. Make a list with a list comprehension.

## Quiz
1. What's an iterable?
2. What's an instance method?
3. What is `self`?
4. How can you make a dictionary from two lists?
5. What should be capitalized in the name of a constant? 

## Explain
Explain what a class is and what an object is.

## Joke Break
*How do you make a tissue dance?*

You put a little boogie in it.

# Installing and Importing Packages
Packages created by the community make Python super useful. Packages exist to help you do nearly any software-related you can think of. As you use Python more, you'll become very familiar with packages. 

[`pandas`](https://pandas.pydata.org/) is an extremely popular package for data analysis and data science. I'm working on another Memorable Tech book about Pandas. [Join my mailing list](https://dataawesome.us20.list-manage.com/subscribe?u=b694acf1df58e5bb039ce60a6&id=5da23b7424) or [follow me on Twitter](https://twitter.com/discdiver) to make sure you don't miss it. 

![Pandas](images/pandas.jpg){#figcaption:pandas}

Let's learn how to see which packages are installed in our environment.

## See Installed Packages
Colab has a number of useful third-party packages pre-installed.

See what package versions are installed in your current environment with the `!pip list` command.

```python
    !pip list
```

This will print all the installed packages and their versions. I haven't shown all the output here, because it's a bit much. But you should definitely try it in your environment.

## Install a Package 
You can install a package from a third party into your environment by using [pip](https://pypi.org/project/pip/) (PyPI). Pip is the official Python package installer.

Install a package into your environment using pip from within Colab like this:

 ```
 python
    !pip install pandas 
```

I'll also spare you the output here.

## Upgrade a Package
You will need to upgrade packages frequently to get the latest features, bug fixes, and security updates. Upgrade a package like this:

```python
    !pip install pandas --upgrade 
```

## Import Packages
To make the functions and classes in a module available in your code, you then need to import the module. Each imported module should be on its own line, at the top of your file.

![Import](images/container_load.jpg){#figcaption:container_load}

```python
import pandas as pd
```

Pandas is commonly imported as `pd`. This leads to less typing.

Python comes bundled with a number of package modules that you don't need to install. These packages are called the *Python standard library*.

Let's import the `math` module that's part of the standard library. 

```python
import math
```

Then you can call the `sqrt` function later in your code like this:

```python
math.sqrt(8)
```

    2.8284271247461903

If the `math` module wasn't part of the standard library you'd have to install it into our environment ‚Äî or it would have to come preinstalled in our Colab environment.

Instead of importing all the classes and methods that are in a module in one fell swoop with `import math`, you can import a particular function from a module like this:

```python
from math import sqrt
```

Notice that you don't put parentheses at the end of the function when you import it. You aren't calling it.

Then you call the function like this, without prepending `math`. 

```python
sqrt(9)
```

    3.0

Importing specific functions and classes helps avoid naming collisions. However, it's convenient for folks reading your code to see where a function came from without having to find the `import` statement.

I suggest importing the whole module if you are using many parts of it and you are doing exploratory work. 

You can import multiple functions from the same module on the same line, like this:

```python
from math import sqrt, cos
```

Just separate the function names with a comma. 

The docs for most modules are available on [GitHub](https://github.com) and [PyPI](https://pypi.org), or linked to from those sources. The docs for most modules are quite helpful. üòÉ

## Summary
You'll be installing packages and importing modules frequently.

### Recap
See all installed packages with `!pip list`.

Install a package with `!pip install some_package`.

Upgrade a package with `!pip install some_package --upgrade`.

Import all the functions and classes in a module with `import some_module`.

Then call an imported function with `some_module.some_function()`.

Import a module under another name with `import some_module as some_name`.

Import a specific function from a module with `from some_module import some_function`.

Then call the imported function with `some_function()`.

Import two functions from a module with `from some_module import first_function, second_function`.

## Practice
1. Install [pybraries](https://pypi.org/project/pybraries/) into your colab environment.
2. Import `pybraries` into your notebook.
3. Upgrade your colab environment to the latest version of `spacy`.
4. Import `tensorflow` into your notebook. It's preinstalled in your Colab environment.
5. Find the docs for `tensorflow`.

## Quiz
1. How do you return all the keys from a dict?
2. How do you remove the second value in a list?
3. What does a list comprehension do?
4. How do your reverse a string?
5. How do you use `zip()` to combine two lists into a dict using a dict comprehension?

## Explain
Explain the difference between your environment and your notebook to someone.

# Conclusion
You've done so much Python in this book. Go you! You've also survived some terrible jokes. üòÇ

Way to rock it! Just remember, learning any technology requires persistence. You can do things to learn more quickly, but at the end of the day, it's mostly persistence. Persist! üëç

## Next Steps
There is more of the Python language and ecosystem to explore. Notably, I didn't include discussions of sets and tuples. I also kept out more advanced talk of function-like things such as generators, decorators, and lambda functions. Don't worry, that more advanced stuff is in the works for Memorable Python Part 2. üòÄ 

In the interim [Real Python](https://realpython.com) and [Trey Hunner's website](https://treyhunner.com/) cover intermediate Python material well.

If you're looking to learn data analysis with Python, I suggest you learn Pandas next. I have a Memorable Pandas book outlined. Until then, I suggest you check out Kevin Markham's Data School [YouTube videos](https://www.youtube.com/watch?v=yzIMircGU5I) and Wes McKinney's book [Python for Data Analysis](https://www.amazon.com/Python-Data-Analysis-Wrangling-IPython-ebook/dp/B075X4LT6K).

A book is a product and all products should be managed for continuous improvement. Please let me know what worked for you and what didn't. üó£

Subscribe to my [mailing list](http://eepurl.com/gjfLAz) so you know when Memorable Tech learning tools are released. I've got several pieces of content in the works. üôå

If you found this helpful, pretty please with a cherry on top, write a review. üçí

Reviews are a primary way for people to find learning resources. If this book is helpful, I want as many people as possible to find it so they learn Python. Also, there's a never-ending battle against fake reviews on the internet. The best way we to combat them is for real reviews to drown them out. Remember, only you can make a real review. ‚ô•Ô∏è

Congratulations on how far you've come. Keep it up! It's use it or lose it with programming languages, so go use it! I can't wait to see what you build! üî®